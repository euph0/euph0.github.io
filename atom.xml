<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eupho&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-05T07:31:24.741Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Eupho</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Intel 启动保护</title>
    <link href="http://example.com/2021/04/05/Intel-%E5%90%AF%E5%8A%A8%E4%BF%9D%E6%8A%A4/"/>
    <id>http://example.com/2021/04/05/Intel-%E5%90%AF%E5%8A%A8%E4%BF%9D%E6%8A%A4/</id>
    <published>2021-04-05T07:02:58.000Z</published>
    <updated>2021-04-05T07:31:24.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Backgound"><a href="#Backgound" class="headerlink" title="Backgound"></a>Backgound</h1><p>能否在公司 Intel 的工作站上启用 secure boot，保证用户启动的是定制化、受管控的系统？</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p><strong>Platform key (PK)</strong>: Establish a trust relationship between the platform owner (PC Manufacturer/OEM) and the firmware (UEFI BIOS) and control access to the KEK database. This is considered as the Root of Trust.</p><a id="more"></a><p><strong>KEK</strong>: Key Exchange Key establishes trust between Operating Systems and the platform firmware. KEK’s are installed in the platform by the OS and/or third party components which want to communicate with platform firmware.</p><p><strong>DB</strong>: Authorized Database holding the public keys and certificates of the code module that is authorized to interact with platform firmware.</p><p><strong>DBX</strong>: Black listed DB. Any code module that matches to these certificates will not be allowed to start loading.</p><p><strong>Signature</strong>: Signature is generated by the private key and hash of the binary that will be signed.</p><p><strong>Certificate</strong>: Authenticode certificate containing public key that corresponds to the private key used to sign the image.</p><h1 id="Secure-boot流程"><a href="#Secure-boot流程" class="headerlink" title="Secure boot流程"></a>Secure boot流程</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>当 Windows PC 加电启动时，会首先找到操作系统引导加载程序。无 Secure Boot 功能的 PC 会直接引导硬盘中的任何引导加载程序，PC 无法知道它是一个值得信赖的操作系统还是 rootkit。<br>当装有 UEFI 的 PC 启动时，PC 会首先验证固件是否经过数字签名，从而降低 Firmware Rootkit 的风险。如果启用 Secure Boot，固件将检查引导加载程序的数字签名并验证其是否被篡改过。如果引导加载程序完整无误，而且满足以下条件之一，固件才会启动引导程序：</p><ul><li><strong>引导程序使用受信任的证书进行了签名</strong>。 对于经过 Windows 10 认证的 PC， Microsoft® 证书是可信的。</li><li><strong>用户手动批准了引导加载程序的数字签名</strong>。 这允许用户加载非 Microsoft 操作系统。<img src="/2021/04/05/Intel-%E5%90%AF%E5%8A%A8%E4%BF%9D%E6%8A%A4/Windows-10-UEFI-Secure-Boot.jpg" class></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>安全启动的工作方式要求将密钥存储在计算机主板的芯片中，并且没有集中式的方法来添加或删除此类密钥。这意味着计算机制造商将可以控制哪些软件可以在他们制造的计算机上运行。<br>当然，仅由于其市场主导地位，微软将始终将其密钥嵌入PC制造商的计算机中。而且，微软要求制造商包括安全启动功能，并在启用此功能的情况下装运客户端计算机，以便获得在将来的计算机上使用 Windows 8 徽标的权利。（2011-2012年）<br>因此其他操作系统的人指责微软造成了某种形式的垄断行为。<br>这个问题后来的解决方案就是微软愿意为额外引入的一个小型引导Shim提供签名，之后由Shim负责为2nd-stage bootloader进行签名验证，提供Mokmanager、mokutil工具用于证书管理<br>因此其他的Linux发行版，例如Ubuntu, Fedora, Red Hat Enterprise Linux, and openSUSE, 就需要将自己的证书导入Shim的数据库。<br>以Ubuntu启动为例，</p><img src="/2021/04/05/Intel-%E5%90%AF%E5%8A%A8%E4%BF%9D%E6%8A%A4/ubuntu_boot.png" class><p>概括一下，简单来说的启动流程是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EFI → Shim → GRUB2 → Kernel → Kernel Module</span><br></pre></td></tr></table></figure><p>EFI信任Shim是因为Shim被Microsoft签名，证书存放在固件里<br>Shim验证GRUB2和Kernel是否被Canonical签名<br>GRUB2引导Kernel启动OS</p><h1 id="理论上的方案"><a href="#理论上的方案" class="headerlink" title="理论上的方案"></a>理论上的方案</h1><p><strong>方案一</strong>：不进入secure boot，自己写一个引导，引导定制的操作系统<br>问题：开发成本较大，且不能保证稳定性，仍需 oem 配合签名</p><p><strong>方案二</strong>：进入secure boot之后，让签名能够被验证通过</p><ul><li><p>获得受硬件厂商认可的操作系统厂商（如Windows）的签名，问题是：</p><ul><li>微软不给签：<a href="https://techcommunity.microsoft.com/t5/hardware-dev-center/updated-uefi-signing-requirements/ba-p/1062916">updated-uefi-signing-requirements</a><img src="/2021/04/05/Intel-%E5%90%AF%E5%8A%A8%E4%BF%9D%E6%8A%A4/microsift_sign_rejection.png" class></li><li>shim也不给签：<a href="https://github.com/rhboot/shim-review">shim-review</a><img src="/2021/04/05/Intel-%E5%90%AF%E5%8A%A8%E4%BF%9D%E6%8A%A4/shim_review.png" class></li></ul></li><li><p>微软签名了某些 bootloader（如shim，preloader），可以通过这些 bootloader 去启动我们的定制 os<br>问题是：攻击者也可以通过这条路往list里面加自己的签名，类似重打包</p></li></ul><h1 id="几种实验"><a href="#几种实验" class="headerlink" title="几种实验"></a>几种实验</h1><h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><p>修改bios → enable secure boot</p><img src="/2021/04/05/Intel-%E5%90%AF%E5%8A%A8%E4%BF%9D%E6%8A%A4/6.1a.png" class><p>修改shim里的secure boot state</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mokutil --enable-validation</span><br></pre></td></tr></table></figure><img src="/2021/04/05/Intel-%E5%90%AF%E5%8A%A8%E4%BF%9D%E6%8A%A4/6.1b.png" class><h2 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h2><p>replace kernel with signed kernel using a key not in DB</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp /boot/vmlinuz-&lt;version&gt;-generic.efi.signed \</span><br><span class="line">          /boot/vmlinuz-&lt;version&gt;-generic.efi.signed.bak</span><br><span class="line">$ sudo sbsign --key /etc/secureboot/key-material/test-key.rsa \</span><br><span class="line">              --cert /etc/secureboot/key-material/test-cert.pem \</span><br><span class="line">              --output /boot/vmlinuz-&lt;version&gt;-generic.efi.signed \</span><br><span class="line">              /boot/vmlinuz-&lt;version&gt;-generic.efi.signed.bak</span><br></pre></td></tr></table></figure><img src="/2021/04/05/Intel-%E5%90%AF%E5%8A%A8%E4%BF%9D%E6%8A%A4/6.2.png" class><h2 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h2><p>Enroll with the right test key</p><img src="/2021/04/05/Intel-%E5%90%AF%E5%8A%A8%E4%BF%9D%E6%8A%A4/6.3.gif" class="Enroll"><h2 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h2><p>破坏原系统的引导，插上启动盘，即可不通过修改BIOS重装系统 → 设置bios管理员密码无效</p><img src="/2021/04/05/Intel-%E5%90%AF%E5%8A%A8%E4%BF%9D%E6%8A%A4/6.4.png" class><p>可通过关闭usb启动解决该问题，但攻击者同样可以直接对硬盘进行分区然后重装系统</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>开启 secure boot 之后可以通过自签名的方式正常启动定制，但是这一行为任何拥有系统root权限的人都可以做到，因此无法禁止root用户自行签名从而修改我们的系统OS</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Backgound&quot;&gt;&lt;a href=&quot;#Backgound&quot; class=&quot;headerlink&quot; title=&quot;Backgound&quot;&gt;&lt;/a&gt;Backgound&lt;/h1&gt;&lt;p&gt;能否在公司 Intel 的工作站上启用 secure boot，保证用户启动的是定制化、受管控的系统？&lt;/p&gt;
&lt;h1 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Platform key (PK)&lt;/strong&gt;: Establish a trust relationship between the platform owner (PC Manufacturer/OEM) and the firmware (UEFI BIOS) and control access to the KEK database. This is considered as the Root of Trust.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Trusted Computing" scheme="http://example.com/tags/Trusted-Computing/"/>
    
  </entry>
  
  <entry>
    <title>Python 代码保护</title>
    <link href="http://example.com/2021/04/05/Python-%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4/"/>
    <id>http://example.com/2021/04/05/Python-%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4/</id>
    <published>2021-04-05T03:39:51.000Z</published>
    <updated>2021-04-05T06:34:24.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>Python 作为一门解释性语言，其特性决定了保护难度会比编译型的 C、C++ 要来的复杂许多。<br>通常情况下，我们要运行一个 python 代码会怎么做？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python test.py</span><br></pre></td></tr></table></figure><a id="more"></a><p>真正的可执行文件当然不是普通的 .py 文件，我们可以使用 compileall 模块显示地查看编译完成的可执行文件 .pyc（Linux  平台下对应 .pyc, Windows 平台对应 .pyd）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ python -m compileall test.py</span><br><span class="line">Compiling test.py ...</span><br><span class="line">$ ls</span><br><span class="line">test.py     test.pyc</span><br><span class="line">$ xxd test.pyc</span><br><span class="line">00000000: 03f3 0d0a 9a87 6a60 6300 0000 0000 0000  ......j`c.......</span><br><span class="line">00000010: 0003 0000 0040 0000 0073 1b00 0000 6400  .....@...s....d.</span><br><span class="line">00000020: 0084 0000 5a00 0065 0000 6401 0064 0200  ....Z..e..d..d..</span><br><span class="line">00000030: 8302 0047 4864 0300 5328 0400 0000 6302  ...GHd..S(....c.</span><br><span class="line">00000040: 0000 0002 0000 0002 0000 0043 0000 0073  ...........C...s</span><br><span class="line">00000050: 0800 0000 7c00 007c 0100 1753 2801 0000  ....|..|...S(...</span><br><span class="line">00000060: 004e 2800 0000 0028 0200 0000 7401 0000  .N(....(....t...</span><br><span class="line">00000070: 0061 7401 0000 0062 2800 0000 0028 0000  .at....b(....(..</span><br><span class="line">00000080: 0000 7307 0000 0074 6573 742e 7079 7403  ..s....test.pyt.</span><br><span class="line">00000090: 0000 0061 6464 0100 0000 7302 0000 0000  ...add....s.....</span><br><span class="line">000000a0: 0169 0300 0000 6905 0000 004e 2801 0000  .i....i....N(...</span><br><span class="line">000000b0: 0052 0200 0000 2800 0000 0028 0000 0000  .R....(....(....</span><br><span class="line">000000c0: 2800 0000 0073 0700 0000 7465 7374 2e70  (....s....test.p</span><br><span class="line">000000d0: 7974 0800 0000 3c6d 6f64 756c 653e 0100  yt....&lt;module&gt;..</span><br><span class="line">000000e0: 0000 7302 0000 0009 03                   ..s......</span><br></pre></td></tr></table></figure><p>一般情况下，.pyc 文件会在一个 python 代码被 import 的时候自动由 Python 解释器创建完成，里面就是编译出来的 bytecode，之后运行的时候 Python 解释器会自动检查 .py 文件的修改时间是否迟于 .pyc 可执行文件<br>如果 .py 文件没有被修改，那么解释器会选择执行 .pyc 文件；如果 .py 被修改了，那么解释器会使用最新的 .py 文件，但也会重新再声成一份 .pyc 文件，以备下次使用。<br>这样做的目的很显然，就是为了加快一点速度。</p><h1 id="pyc-为什么不能保护代码？"><a href="#pyc-为什么不能保护代码？" class="headerlink" title=".pyc 为什么不能保护代码？"></a>.pyc 为什么不能保护代码？</h1><h2 id="一开始的尝试"><a href="#一开始的尝试" class="headerlink" title="一开始的尝试"></a>一开始的尝试</h2><p>那再回到 Python 代码保护上来，是不是我们只要保存源代码 .py, 只给出可执行文件 .pyc 就可以了呢？<br>答案是否定的，Python 已经有了 uncompyle6 模块，适用于 Python 2.7 &amp; 3.x，可以从 .pyc 一键还原 python 代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ pip install uncompyle6</span><br><span class="line">$ uncompyle6 test.pyc</span><br><span class="line"><span class="comment"># uncompyle6 version 3.7.4</span></span><br><span class="line"><span class="comment"># Python bytecode 2.7 (62211)</span></span><br><span class="line"><span class="comment"># Decompiled from: Python 2.7.16 (default, Jan 27 2020, 04:46:15)</span></span><br><span class="line"><span class="comment"># [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)]</span></span><br><span class="line"><span class="comment"># Embedded file name: test.py</span></span><br><span class="line"><span class="comment"># Compiled at: 2021-04-05 11:44:26</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(a, b):</span><br><span class="line">    <span class="built_in">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> add(3, 5)</span><br><span class="line"><span class="comment"># okay decompiling test.pyc</span></span><br><span class="line">$ cat test.py</span><br><span class="line">def add(a, b):</span><br><span class="line">    <span class="built_in">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(3, 5))</span><br></pre></td></tr></table></figure><p>可以看到，对 python 源代码是可以高度还原的。uncompyle6 的工作原理详见<a href="https://github.com/rocky/python-uncompyle6/">github: uncompyle6</a>，其中很重要的一点是，uncompyle6 是根据 .pyc 前4个字节（magic number）来判断 python 代码版本的。</p><h2 id="做出一点改进"><a href="#做出一点改进" class="headerlink" title="做出一点改进"></a>做出一点改进</h2><p>既然 uncompyle6 是根据 magic number 进行处理的，是不是我修改一下 magic number 让它无法识别就可以达到目的了呢？<br>显然也是不行的，原因有以下两点：</p><ul><li>Python 版本就那么多，其实一个个枚举很容易找到正确的 magic number</li><li>.pyc 里面其实包含很多可读信息，例如 import 了什么库，还有字符串也是直接可以看出来的</li></ul><h1 id="还有哪些现成方案？"><a href="#还有哪些现成方案？" class="headerlink" title="还有哪些现成方案？"></a>还有哪些现成方案？</h1><p>除此以外还调研了有些其他的现成方案，例如</p><ul><li>pyminifier</li></ul><p>通过调用第三方库，变量、函数名称混淆，增加阅读代码难度，但是可以轻易编写脚本去混淆，使代码变得可读</p><ul><li>pyinstaller+加壳混淆</li></ul><p>通过调用开源PyCrypto，使用 –key=key-string 对代码进行加密，但是生成的是 Windows<br>平台下的 exe 可执行文件</p><ul><li>pyarmor</li></ul><p>调用第三方库，把字节码做一定程度上的加密，并最后调用so文件来解密，但是so文件未作加固，可以直接逆向分析</p><h1 id="初版方案"><a href="#初版方案" class="headerlink" title="初版方案"></a>初版方案</h1><p>综合以上调研之后，得到了第一版的方案，主要做了以下几点：</p><ul><li>修改 opcode 映射关系，参考<a href="http://phantom0301.cc/2017/03/24/pythonopcode/">Python 与 opcode</a></li><li>由于 opcode.py 里还是有相应的内容，并且为了做到字符串内容的保护，hook 了 Python 源代码<br>通过修改 Python/fileutils.c 中的 FILE* _Py_fopen_hook(const char *pathname, const char *mode) 函数，将 pyc 文件的打开过程添加一层解密</li><li>使用 ollvm 混淆我们修改的函数，增大 diff 逆向的难度</li><li>Python 源码编译完成后，修改 lib/python3.5/py_compile.py，在生成 pyc 文件之前添加一层 AES 加密</li><li>修改完毕所有的 Python 代码之后，使用以下命令将所有的 .py 文件编译成为加密的 .pyc 文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m compileall &lt;target_python_code_directory&gt;</span><br></pre></td></tr></table></figure><ul><li>最后，为了保护源码中硬编码的加密秘钥，在解密的步骤中添加了运行时自修改模块（SMC）</li></ul><p>以上多个步骤结合起来，能够得到一款定制的 Python 解释器，被加密的 pyc 可执行文件只能使用这款解释器运行，同时使用者仅会获得 pyc 文件，也很难恢复出对应源码</p><p>该方案的主要缺点在于：</p><ul><li>严重依赖 Python 版本，甚至每一个小版本都需要做特定的修改</li><li>一旦 import 过多的第三方库，运行加解密时间就会过长，难以接受</li><li>加密秘钥硬编码，易还原出修改后的 opcode 映射</li></ul><h1 id="第二版方案"><a href="#第二版方案" class="headerlink" title="第二版方案"></a>第二版方案</h1><p>在初版方案的基础上，修改加解密算法为 RC4，使用时分为 runtime 和 xcrypt 两个解释器<br>前者只能用于运行加密后的 pyc （提供给用户），后者还可以编译加密 python 代码</p><p>该方案的主要缺点在于：</p><ul><li>依旧严重依赖 Python 版本</li><li>通过区分解释器是 opcode 还原难度倍增，但没有从根本上解决加密秘钥硬编码的问题</li></ul><h1 id="第三版方案"><a href="#第三版方案" class="headerlink" title="第三版方案"></a>第三版方案</h1><p>转化思路，将原来保护 Python 的问题利用 Cython 转化为保护 c 语言编译得到的 so 库的问题，再使用 VMProtect 针对 so 进行加壳，相比较起来优点在于：</p><ul><li>运行速度提升了</li><li>使用 vmp 虚拟化增大了逆向难度</li><li>一旦保护方案失效了，攻击者获取的也是编译得到的 so 库（即代码逻辑），而不像之前的方案会直接获得 Python 源码</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h1&gt;&lt;p&gt;Python 作为一门解释性语言，其特性决定了保护难度会比编译型的 C、C++ 要来的复杂许多。&lt;br&gt;通常情况下，我们要运行一个 python 代码会怎么做？&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;python test.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LLVM &amp; OLLVM &amp; (?)LLVM</title>
    <link href="http://example.com/2021/04/04/LLVM-OLLVM-LLVM/"/>
    <id>http://example.com/2021/04/04/LLVM-OLLVM-LLVM/</id>
    <published>2021-04-04T10:55:32.000Z</published>
    <updated>2021-04-05T06:32:28.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经典编译器设计"><a href="#经典编译器设计" class="headerlink" title="经典编译器设计"></a>经典编译器设计</h1><img src="/2021/04/04/LLVM-OLLVM-LLVM/compilerConcept.png" class><p>一个传统静态编译器（像大多数C编译器）最流行的设计是3阶段的设计，其中主要组件是前端，优化器及后端（如上图）</p><a id="more"></a><p>前端：负责解析源代码，检查错误，并构建一个特定于语言的抽象语法树（AST）来代表输入的代码</p><ul><li>（optional）AST被转换到一个新的用于优化的表示，优化器及后端可以运行这个代码</li></ul><p>优化器：负责进行各种转换尝试改进代码的运行时间，比如重复计算消除，通常或多或少与语言及目标无关<br>后端：也被称为代码产生器；把代码映射入目标指令集，通用部分包括指令选择，寄存器分配，及指令调度</p><p><strong>为什么要这样设计?</strong><br>当一个编译器决定支持多个源语言或目标架构时，这种经典设计最重要的收益出现了<br>如果编译器在其优化器中使用一个通用的代码表示，那么可以为任何可以编译到这个表示的语言编写一个前端，且为任何可以从这个表示编译得到的目标编写一个后端，如下图所示</p><img src="/2021/04/04/LLVM-OLLVM-LLVM/modernCompiler.png" class><p>否则，实现一个新源语言将要求从头开始，因此支持 N 个目标及 M 个源语言将需要 N*M 种编译器</p><h1 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h1><p>LLVM 过去是 Low Level Virtual Machine 的首字母缩写，但现在只是这个综合项目的一个标签，并因某些很好的工具而闻名（比如 Clang 编译器，一个在 GCC 编译器上提供了若干好处的 C/C++/Objective-C 编译器）</p><h2 id="LLVM的代码表示：LLVM-IR（Frontend）"><a href="#LLVM的代码表示：LLVM-IR（Frontend）" class="headerlink" title="LLVM的代码表示：LLVM IR（Frontend）"></a>LLVM的代码表示：LLVM IR（Frontend）</h2><p>LLVM 现在被用作一个通用的基础设施来实现各种静态及运行时编译的语言，其设计最重要的方面是 LLVM 中间表示（IR）</p><ul><li>在一个基于 LLVM 的编译器中，一个前端负责对输入代码解析，验证及诊断错误，然后把解析的代码转换到 LLVM IR（通常，但不总是，通过构建一棵 AST，然后把这个 AST 转换为 LLVM IR）。这个 IR 可选地通过一系列改进代码的分析及优化遍，然后发送到一个代码生成器来产生本地机器码</li></ul><p>下面是一个简单的.ll文件例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">define i32 @add1(i32 %a, i32 %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %tmp1 &#x3D; add i32 %a, %b</span><br><span class="line">  ret i32 %tmp1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i32 @add2(i32 %a, i32 %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %tmp1 &#x3D; icmp eq i32 %a, 0</span><br><span class="line">  br i1 %tmp1, label %done, label %recurse</span><br><span class="line"></span><br><span class="line">recurse:</span><br><span class="line">  %tmp2 &#x3D; sub i32 %a, 1</span><br><span class="line">  %tmp3 &#x3D; add i32 %b, 1</span><br><span class="line">  %tmp4 &#x3D; call i32 @add2(i32 %tmp2, i32 %tmp3)</span><br><span class="line">  ret i32 %tmp4</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">  ret i32 %b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 LLVM IR 对应以下 C 代码，它提供了两个不同的方式来加整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unsigned add1(unsigned a, unsigned b) &#123;</span><br><span class="line">  return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Perhaps not the most efficient way to add two numbers.</span><br><span class="line">unsigned add2(unsigned a, unsigned b) &#123;</span><br><span class="line">  if (a &#x3D;&#x3D; 0) return b;</span><br><span class="line">  return add2(a-1, b+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LLVM是一个库的集合（Optimizer）"><a href="#LLVM是一个库的集合（Optimizer）" class="headerlink" title="LLVM是一个库的集合（Optimizer）"></a>LLVM是一个库的集合（Optimizer）</h2><p>除了 LLVM IR 设计，LLVM 下一个最重要的方面是，它被设计为一组库，而不是作为一个整体命令行编译器，例如 GCC<br>优化器从读入 LLVM IR 代码开始，经过很多种不同的优化（optimization passes），根据输入的不同，对IR进行针对性的一些改变</p><ul><li>在这里每个 pass 都被写成一个 C++ 类，由 Pass 类继承而来</li><li>大多数的 pass 都是写在一个单独的类文件(.cpp)中的，这些pass文件都被编译成为 .o 文件，接着会被链接打包成为一系列 .a 库文件，这些库文件提供了很多分析与翻译的功能</li><li>Pass 之间都尽可能松地耦合：相互之间尽可能保持独立，或者明确定义 Pass 之间的依赖关系，方便 PassManager 管理与正确执行<br>这种基于库的实现方式允许 LLVM 提供大量的功能，如果你只是需要 LLVM 中的一些简单的功能，那么只需要指定运行的 pass 文件而不需要管所有的优化 pass</li></ul><h2 id="LLVM代码生成器的设计（Backend）"><a href="#LLVM代码生成器的设计（Backend）" class="headerlink" title="LLVM代码生成器的设计（Backend）"></a>LLVM代码生成器的设计（Backend）</h2><p>LLVM 代码生成器负责把 LLVM IR 转换为目标特定的机器代码<br>和优化器采用的方式类似，LLVM 的代码生成器将代码生成的问题分离成独立的 pass，例如指令选择，寄存器分配，建表，代码布局优化以及提供默认的内建 pass 等等</p><h1 id="编写一个自己的LLVM-pass"><a href="#编写一个自己的LLVM-pass" class="headerlink" title="编写一个自己的LLVM pass"></a>编写一个自己的LLVM pass</h1><p>网上有很多这样的教程参考，但仔细阅读之后发现都是基于相对很老的版本，内容方法与最新的版本出入很大，因此此处基于<a href="https://llvm.org/docs/WritingAnLLVMNewPMPass.html">latest官方文档</a>编写一个自定义的 pass “HelloWorld”，能够打印出所有 non-external 函数名</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><em>Software Requirements</em><br>CMake &gt;=3.13.4 GCC &gt;=5.1.0 python &gt;=3.6 zlib &gt;=1.2.3.4 GNU Make 3.79 3.79.1<br><em>Installations</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check out the LLVM project:</span></span><br><span class="line"><span class="comment"># Change directory to where you want the llvm directory placed.</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/llvm/llvm-project.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># build LLVM and Clang</span></span><br><span class="line"><span class="built_in">cd</span> llvm-project</span><br><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -DLLVM_ENABLE_PROJECTS=clang -G <span class="string">&quot;Unix Makefiles&quot;</span> ../llvm</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>执行以上命令之后，大概需要等五个小时，就可以编译成功<br>可以尝试通过执行以下命令检查安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang --<span class="built_in">help</span></span><br><span class="line">make check-clang</span><br></pre></td></tr></table></figure><blockquote><p>Reference: <a href="https://clang.llvm.org/get_started.html">Getting Started: Building and Running Clang</a></p></blockquote><h2 id="添加新pass"><a href="#添加新pass" class="headerlink" title="添加新pass"></a>添加新pass</h2><ul><li>在 llvm/include/llvm/Transforms/ 目录下新建文件夹 HelloWorld，然后新建文件 HelloYichen.h，里面内容如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LLVM_TRANSFORMS_HELLOWORLD_HELLOYICHEN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLVM_TRANSFORMS_HELLOWORLD_HELLOYICHEN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/PassManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> llvm &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HelloYichenPass</span> :</span> <span class="keyword">public</span> PassInfoMixin&lt;HelloYichenPass&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function">PreservedAnalyses <span class="title">run</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;AM)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace llvm</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>在 llvm/lib/Transforms/ 目录下新建文件夹 HelloWorld，然后新建文件 HelloYichen.cpp，里面内容如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/HelloWorld/HelloYichen.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">HelloYichenPass::run</span><span class="params">(Function &amp;F,</span></span></span><br><span class="line"><span class="function"><span class="params">        FunctionAnalysisManager &amp;AM)</span> </span>&#123;</span><br><span class="line">    errs() &lt;&lt; <span class="string">&quot;Hello &quot;</span> &lt;&lt; F.getName() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> PreservedAnalyses::all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改 llvm/lib/Transforms/CMakelists.txt，添加</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(HelloWorld)</span><br></pre></td></tr></table></figure><ul><li>修改 llvm/lib/Passes/PassRegistry.def，添加</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION_PASS(&quot;helloyichen&quot;, HelloYichenPass())</span><br></pre></td></tr></table></figure><ul><li>修改 llvm/lib/Passes/PassBuilder.cpp，添加</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/HelloWorld/HelloYichen.h&quot;</span></span></span><br></pre></td></tr></table></figure><ul><li>修改 llvm/lib/Passes/CMakelists.txt，在DEPENDS里添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld</span><br></pre></td></tr></table></figure></li></ul><h2 id="重新编译"><a href="#重新编译" class="headerlink" title="重新编译"></a>重新编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build/</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>大概需要等待半小时左右，打印以下信息即编译完毕</p><img src="/2021/04/04/LLVM-OLLVM-LLVM/compilationSucceeds.png" class><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>新建任意一个 .c 文件：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">10</span>;</span><br><span class="line">    a = sum(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译生成 LLVM 可视化字节码文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O3 -emit-llvm test.c -S -o test.ll</span><br></pre></td></tr></table></figure><ul><li>测试编写的 pass</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-project/build/bin/opt -disable-output test.ll -passes=helloyichen</span><br></pre></td></tr></table></figure><p>输出以下内容即为正确</p><img src="/2021/04/04/LLVM-OLLVM-LLVM/hello.png" class><h1 id="OLLVM"><a href="#OLLVM" class="headerlink" title="OLLVM"></a>OLLVM</h1><p>OLLVM（Obfuscator-LLVM）是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目，该项目旨在提供一套开源的针对 LLVM 的代码混淆工具，以增加对逆向工程的难度<br>简单来说，OLLVM 最大的贡献就是在 LLVM 的基础上添加了以下提供代码混淆功能的 Pass</p><h2 id="指令替换-Instruction-Substitution"><a href="#指令替换-Instruction-Substitution" class="headerlink" title="指令替换 (Instruction Substitution)"></a>指令替换 (Instruction Substitution)</h2><p>本质上指令替换就是用等价的更加复杂的指令替换原本可读性更好的指令。比如，加减以及布尔指令</p><h2 id="控制流平坦化-Control-Flow-Flattening"><a href="#控制流平坦化-Control-Flow-Flattening" class="headerlink" title="控制流平坦化 (Control Flow Flattening)"></a>控制流平坦化 (Control Flow Flattening)</h2><p>该模式改变原本程序的控制流，主要是把一些 if-else 语句，嵌套成 do-while 语句<br>例如源程序的控制流和经过平坦化后的控制流如下：</p><ul><li>before:</li></ul><img src="/2021/04/04/LLVM-OLLVM-LLVM/before.png" class><ul><li>after:</li></ul><img src="/2021/04/04/LLVM-OLLVM-LLVM/after.png" class><h2 id="控制流伪造-Bogus-Control-Flow"><a href="#控制流伪造-Bogus-Control-Flow" class="headerlink" title="控制流伪造 (Bogus Control Flow)"></a>控制流伪造 (Bogus Control Flow)</h2><p>也是对程序的控制流做操作，不同的是，BCF 模式会在原代码块的前后随机插入新的代码块，新插入的代码块不是确定的，然后新代码块再通过条件判断跳转到原代码块中<br>并且原代码块可能会被克隆并插入随机的垃圾指令</p><h2 id="字符串混淆-String-Obfuscation"><a href="#字符串混淆-String-Obfuscation" class="headerlink" title="字符串混淆  (String Obfuscation)"></a>字符串混淆  (String Obfuscation)</h2><p>混淆后的字符串没办法直接搜索到，变成一系列操作后的合成产物，提高了反编译成本</p><h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解 (Annotation)"></a>注解 (Annotation)</h2><p>有的时候，由于效率或其他原因的考虑，我们只想给指定的函数混淆或不混淆该函数，OLLVM也提供了对这一特性的支持，你只需要给对应的函数添加 attributes 即可<br>例如想对函数foo()使用fla混淆:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> __<span class="title">attribute</span><span class="params">((__annotate__((<span class="string">&quot;fla&quot;</span>))))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LLVM-1"><a href="#LLVM-1" class="headerlink" title="(?)LLVM"></a>(?)LLVM</h1><p>上面提到的 OLLVM 是一个开源的、相对成熟的解决方案，但由于</p><ul><li>该项目自从 llvm_4.0 之后就不再提供官方开源维护</li><li>已经有了一些针对 OLLVM 的一些自动 deobfuscator 的插件</li></ul><p>因此，为了代码保护能够保证一定强度和稳定性，同时参考业内商业产品的核心原理，建议基于OLLVM进行定制化的修改</p><h2 id="一些代码-二进制混淆技术"><a href="#一些代码-二进制混淆技术" class="headerlink" title="一些代码/二进制混淆技术"></a>一些代码/二进制混淆技术</h2><h3 id="条件异常"><a href="#条件异常" class="headerlink" title="条件异常"></a>条件异常</h3><p>很多指令和系统操作都可以被用来产生异常，例如非法指令、整数运算、浮点数运算和内存访问操作等<br>条件异常只在设定的条件满足时才会触发异常处理，这样便可以实现程序控制权的转移，从而用来隐藏程序的真正执行流程，增大静态分析的复杂度和抵抗符号执行</p><img src="/2021/04/04/LLVM-OLLVM-LLVM/conditionalException.png" class><h3 id="不透明谓词"><a href="#不透明谓词" class="headerlink" title="不透明谓词"></a>不透明谓词</h3><p>谓词 P 在程序中的某一点 p，如果在混淆之后对于混淆这是可知的（基于先验知识）而对于其他人是难以获知的，则称该谓词为不透明谓词<br>不透明谓词可以被用来向顺序执行的代码中插入条件恒为真或者横为假的路径分支，这些路径分支不影响代码的实际执行顺序，只是使代码的控制流变得复杂且难以分析</p><img src="/2021/04/04/LLVM-OLLVM-LLVM/opaquePredicates.png" class><blockquote><p>Reference: <a href="/2021/04/04/LLVM-OLLVM-LLVM/sp-paper.pdf" title="sp-paper.pdf">sp-paper.pdf</a></p></blockquote><h3 id="切片克隆"><a href="#切片克隆" class="headerlink" title="切片克隆"></a>切片克隆</h3><p>这种方法将程序重要代码进行切片，针对每个代码片段克隆多个等价片段且生成多条随机执行路径，增加代码执行路径的随机多样性，是的攻击者难以恢复和分析原始代码</p><blockquote><p>Reference: <a href="/2021/04/04/LLVM-OLLVM-LLVM/ANewCodeObfuscationSchemeforSoftware.pdf" title="ANewCodeObfuscationSchemeforSoftware.pdf">ANewCodeObfuscationSchemeforSoftware.pdf</a></p></blockquote><h3 id="常量混淆"><a href="#常量混淆" class="headerlink" title="常量混淆"></a>常量混淆</h3><p>通过将常量转化为一系列的运算结果横相等的指令，可以隐藏原始的常量值</p><img src="/2021/04/04/LLVM-OLLVM-LLVM/binaryPatch.png" class><blockquote><p>Reference: <a href="/2021/04/04/LLVM-OLLVM-LLVM/AnLLVMObfuscatorForBinaryPatchGeneration.pdf" title="AnLLVMObfuscatorForBinaryPatchGeneration.pdf">AnLLVMObfuscatorForBinaryPatchGeneration.pdf</a></p></blockquote><h3 id="插入dead-code"><a href="#插入dead-code" class="headerlink" title="插入dead code"></a>插入dead code</h3><p>往原始代码里插入一些dead code，它们要么永远不会被执行，要么即使会被执行，执行完毕的结果也不会被使用</p><h3 id="别名转换-Aliasing"><a href="#别名转换-Aliasing" class="headerlink" title="别名转换 (Aliasing )"></a>别名转换 (Aliasing )</h3><p>别名是指两个甚至更多的不同命名的变量其实指向同一块内存空间，在进行控制流分析时，Aliasing非常重要，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line">*p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">*p = *p + i;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(i);</span><br></pre></td></tr></table></figure><p>如果这里*p是i 的一个别名，那么整个循环只会执行两次就跳出，且i的值为7；如果不是别名的话，整个循环要执行5次，且i的值最后会是5</p><h3 id="更复杂的算术替换"><a href="#更复杂的算术替换" class="headerlink" title="更复杂的算术替换"></a>更复杂的算术替换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x + y &#x3D; x - ¬ y - 1</span><br><span class="line">      &#x3D; (x ⊕ y) + 2·(x ∧ y)</span><br><span class="line">      &#x3D; (x ∨ y) + (x ∧ y)</span><br><span class="line">      &#x3D; 2·(x ∨ y) - (x ⊕ y)</span><br></pre></td></tr></table></figure><h2 id="可以参考的测试集"><a href="#可以参考的测试集" class="headerlink" title="可以参考的测试集"></a>可以参考的测试集</h2><p><a href="https://github.com/tum-i4/obfuscation-benchmarks">obfuscation-benchmarks</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;经典编译器设计&quot;&gt;&lt;a href=&quot;#经典编译器设计&quot; class=&quot;headerlink&quot; title=&quot;经典编译器设计&quot;&gt;&lt;/a&gt;经典编译器设计&lt;/h1&gt;&lt;img src=&quot;/2021/04/04/LLVM-OLLVM-LLVM/compilerConcept.png&quot; class&gt;
&lt;p&gt;一个传统静态编译器（像大多数C编译器）最流行的设计是3阶段的设计，其中主要组件是前端，优化器及后端（如上图）&lt;/p&gt;</summary>
    
    
    
    
    <category term="LLVM" scheme="http://example.com/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>52pojie 2021春节解题领红包 Q3 Writeup</title>
    <link href="http://example.com/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/"/>
    <id>http://example.com/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/</id>
    <published>2021-04-04T10:28:29.000Z</published>
    <updated>2021-04-04T10:49:49.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://down.52pojie.cn/Challenge/Happy_New_Year_2021_Challenge.rar">Happy_New_Year_2021_Challenge</a></p><a id="more"></a><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><h2 id="绕过高版本-sdk-限制"><a href="#绕过高版本-sdk-限制" class="headerlink" title="绕过高版本 sdk 限制"></a>绕过高版本 sdk 限制</h2><p>一开始尝试安装 apk 失败</p><img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/installFailure.png" class><p>失败原因是我手头上的安卓机版本（6.0）太低，中间饶了很多弯路（本来想重新刷机，但这个手机太旧了系统空间容量太小，总是失败）<br>最后的解决办法是给修改 apk 重打包，修改 xml 配置文件里的最低版本要求<br>修改 apktool.xml 中的 sdkinfo，将最小要求从 26 改成 23</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdkInfo:</span><br><span class="line">  minSdkVersion: &#39;23&#39;</span><br><span class="line">  targetSdkVersion: &#39;30&#39;</span><br></pre></td></tr></table></figure><p>修改 AndroidManifest.xml ，改成 true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:extractNativeLibs&#x3D;&quot;true&quot;</span><br></pre></td></tr></table></figure><p>之后重新打包就可以正常安装了</p><h2 id="Java-层"><a href="#Java-层" class="headerlink" title="Java 层"></a>Java 层</h2><p>打开来还是 flag 输入框和验证框，拖到 jadx 里查看 java 代码</p><img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/decompile.png" class><p>和 2020 年的题目类似，还是先对输入的 flag 长度是否等于 30 进行判断，然后进入到 native 层 so 库中的 check 函数进行判断</p><h2 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h2><p>所以我们去IDA里打开来看一下<br>找到 Java_cn_pojie52_cm01_MainActivity_check 函数后，会发现里面首先调用了 sub_7FA30F8B90 函数</p><img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/sub_8B90.png" class><p>接着将返回结果和静态存储的一串数据进行了类似的操作后，得到 v9 和 v19</p><blockquote><p>后来参考了别人的wp，发现这里是 base64</p></blockquote><img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/base64.png" class><p>并且判断两个是否一致，一致就正常退出程序</p><img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/compare.png" class><p>很显然，这里就是判断 flag 输入是否正确的地方<br>转回到 8B90 这个函数来分析，发现是个 rc4 解密，areyousure?????? 就是密钥</p><img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/rc4.png" class><p>这里可以参考 <a href="https://ctf-wiki.org/reverse/identify-encode-encryption/introduction/#rc4">ctf-wiki</a> 中常见加密算法识别，具体怎么看出来的在IDA里面也进行了备注<br>那么接下来就尝试通过IDA动态调试，在比对值是否一致的地方下断点，验证猜测</p><h2 id="启用-IDA-动态调试"><a href="#启用-IDA-动态调试" class="headerlink" title="启用 IDA 动态调试"></a>启用 IDA 动态调试</h2><p>首先将 IDA → dbgsrv → android_server64 拷贝到手机中，运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell <span class="string">&quot;./android_server64 &amp;&quot;</span></span><br><span class="line">adb forward tcp:23946 tcp:23946</span><br><span class="line">adb shell <span class="string">&quot;pm list packages -3&quot;</span> <span class="comment"># -3指第三方应用</span></span><br><span class="line">am start -D -n cn.pojie52.cm01/.MainActivity</span><br></pre></td></tr></table></figure><img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/adb.png" class><p>然后 IDA → Debugger → Process options</p><img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/debugOption.png" class><p>选择 Remote Android Debugger</p><img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/remoteDebugger.png" class><p>在刚进入 check 函数处下一个断点，在while比对处再下一个断点<br>IDA → Debugger → Attach to process，选择 cn.pojie52.cm01</p><img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/startDebug.png" class><p>开始调试，按 F5 进入伪代码模式，输入 flag，F9 运行至断点处，F7/8 单步</p><img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/whileCompare.png" class><p>查看 v9 和 v19 的值</p><ul><li>v9:<img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/v9.png" class></li><li>v19:<img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/v19.png" class></li></ul><p>将 v9 转化为字符串：4Gs3oXXX9tTvGcXAVKP6t3Dty9KxMhgIC1AEjh1+</p><img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/v9_str.png" class><p>解密得到输入值<br>将 v19 转化为字符串：5Gh2/y6Poq2/WIeLJfmh6yesnK7ndnJeWREFjRx8</p><img src="/2021/04/04/52pojie-2021%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/v19_str.png" class><p>解密得到 flag</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://down.52pojie.cn/Challenge/Happy_New_Year_2021_Challenge.rar&quot;&gt;Happy_New_Year_2021_Challenge&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>52pojie 2020春节解题领红包 Q3 Writeup</title>
    <link href="http://example.com/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/"/>
    <id>http://example.com/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/</id>
    <published>2021-04-04T09:48:52.000Z</published>
    <updated>2021-04-04T10:22:21.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://down.52pojie.cn/Challenge/Happy_New_Year_2020_Challenge.rar">Happy_New_Year_2020_Challenge</a></p><a id="more"></a><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><h2 id="Java-层"><a href="#Java-层" class="headerlink" title="Java 层"></a>Java 层</h2><p>首先题目给出来是一个apk</p><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/q.jpg" class><p>拖到jadx里打开查看</p><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/jadx.png" class><p>发现 onCreate 函数是在 java 层实现的，而 onClick 和checkFlag都是在 native 层实现的 Native 层</p><h2 id="Native-层"><a href="#Native-层" class="headerlink" title="Native 层"></a>Native 层</h2><p>因此找到 libcrack_j2c.so，拖进 IDA 里查看，找到其中的两个关键函数</p><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/funclist.png" class><h3 id="一些准备工作"><a href="#一些准备工作" class="headerlink" title="一些准备工作"></a>一些准备工作</h3><p>File → Load file → Parse C header file，导入 <a href="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/jni.h" title="jni.h">jni.h</a><br>选中函数的第一个 int 型参数，右键”Convert to struct *“，在打开的框里选择 JNIEnv，点击 ok</p><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/jniEnv.png" class><p>选中函数名，右键“Force call type”<br>会发现大部分函数会变得更加可读一些</p><h3 id="分析-onClick-函数"><a href="#分析-onClick-函数" class="headerlink" title="分析 onClick 函数"></a>分析 onClick 函数</h3><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/onClick.png" class><p>大意是首先判断输入长度是否为30，如果不满足则跳转输出“flag长度必须为30位”<br>如果满足的话，会调用 checkFlag 进行判断，返回一个boolean值对应输出正确与错误信息<br>因此关键就在 checkFlag 函数</p><h3 id="分析-checkFlag-函数"><a href="#分析-checkFlag-函数" class="headerlink" title="分析 checkFlag 函数"></a>分析 checkFlag 函数</h3><p>首先一进来是反调试</p><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/antiDebug.png" class><p>之后是对三块内存进行字符串赋值，分别为:</p><ul><li>string 1: thisiskey </li><li>string 2: 52pojie_2020_happy_chinese_new_year</li><li>string 3: 20200125</li></ul><p>然后开辟一块新内存存放 35 位的 byte 数组</p><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/byte.png" class><p>接下来会遍历数组，如果 i!=0 &amp;&amp; i%4==0，选取 string3 中下标为 (i&gt;&gt;2)-1 的字符填进 byte 数组，否则选取 string2 中下标为 i 的字符填进 byte 数组</p><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/index.png" class><p>然后对这个 byte 数组做 md5 hash</p><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/hash.png" class><p>然后将 hash 结果与 string1 循环异或 j % len(string1)</p><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/xor.png" class><p>异或结果转 hex，不足 0xF 时高位补 0，得到 32 位字符串</p><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/toHex.png" class><p>将结果截取[1:31]，与输入进行比较</p><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/compare.png" class><p>因此我们只需要按照这个逻辑算一遍，就能知道答案是什么</p><h3 id="编写exp"><a href="#编写exp" class="headerlink" title="编写exp"></a>编写exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;thisiskey&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;52pojie_2020_happy_chinese_new_year&quot;</span></span><br><span class="line">str3 = <span class="string">&quot;20200125&quot;</span></span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">35</span>):</span><br><span class="line">    <span class="keyword">if</span> i != <span class="number">0</span> <span class="keyword">and</span> i % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        res.append(str3[(i&gt;&gt;<span class="number">2</span>)-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res.append(str2[i])</span><br><span class="line"></span><br><span class="line">res = hashlib.md5(<span class="string">&quot;&quot;</span>.join(res)).digest()</span><br><span class="line"></span><br><span class="line">code = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)):</span><br><span class="line">    tmp = <span class="built_in">ord</span>(result[i]) ^ <span class="built_in">ord</span>(str1[i % <span class="number">9</span>])</span><br><span class="line">    code.append(<span class="string">&quot;%02x&quot;</span> % tmp)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;</span>.join(code)[<span class="number">1</span>:<span class="number">31</span>])</span><br></pre></td></tr></table></figure><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/output.png" class><p>输入即可得到正确结果</p><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/success.jpg" class><p>附：<a href="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/libcrack_j2c.so.idb" title="libcrack_j2c.so.idb">libcrack_j2c.so.idb</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://down.52pojie.cn/Challenge/Happy_New_Year_2020_Challenge.rar&quot;&gt;Happy_New_Year_2020_Challenge&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Apk Reverse Engineering 03</title>
    <link href="http://example.com/2021/04/04/Apk-Reverse-Engineering-03/"/>
    <id>http://example.com/2021/04/04/Apk-Reverse-Engineering-03/</id>
    <published>2021-04-04T08:55:17.000Z</published>
    <updated>2021-04-04T11:00:03.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>本文旨在解决 OWASP Project Android 联手项目 Level 2，关注了root检测绕过和反调试检测，而challenge本身也是寻找关键的 secret string</p><a id="more"></a><h1 id="Dive-in"><a href="#Dive-in" class="headerlink" title="Dive in"></a>Dive in</h1><p>首先还是老样子，安装apk到安卓模拟器里</p><img src="/2021/04/04/Apk-Reverse-Engineering-03/install.png" class><img src="/2021/04/04/Apk-Reverse-Engineering-03/frida_fail.png" class><p>这时我们尝试去attach其中的一个进程会发现失败，失败原因后面会解释<br>那只能先反编译看一下源码了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># decompile and convert to source code</span></span><br><span class="line">apkx -d cfr Uncrackable2-Level2.apk</span><br></pre></td></tr></table></figure><img src="/2021/04/04/Apk-Reverse-Engineering-03/decompile.png" class><p>可以看到里面的一些特别之处在于：</p><ul><li>静态load 了一个 libfoo.so</li><li>在 onCreate 方法里调用了 native 函数 init，另外这个 init 函数里面还又调用了 bar 函数</li></ul><p>那么很显而易见，在这个库里肯定有文章<br>这里可以使用radare2/IDA查看</p><h2 id="Radare2"><a href="#Radare2" class="headerlink" title="Radare2"></a>Radare2</h2><ul><li>下载安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install radare2</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/radareorg/radare2</span><br><span class="line"><span class="built_in">cd</span> radare2</span><br><span class="line">sys/install.sh</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># using radare2</span></span><br><span class="line">&gt; r2 ./libfoo.so</span><br><span class="line">Cannot determine entrypoint, using 0x00000840.</span><br><span class="line">Warning: run r2 with -e io.cache=<span class="literal">true</span> to fix relocations <span class="keyword">in</span> disassembly</span><br><span class="line"> -- Here be dragons.</span><br><span class="line">[0x00000840]&gt; aaa</span><br><span class="line">[x] Analyze all flags starting with sym. and entry0 (aa)</span><br><span class="line">[x] Analyze <span class="keyword">function</span> calls (aac)</span><br><span class="line">[x] Analyze len bytes of instructions <span class="keyword">for</span> references (aar)</span><br><span class="line">[x] Check <span class="keyword">for</span> vtables</span><br><span class="line">[x] Type matching analysis <span class="keyword">for</span> all <span class="built_in">functions</span> (aaft)</span><br><span class="line">[x] Propagate noreturn information</span><br><span class="line">[x] Use -AA or aaaa to perform additional experimental analysis.</span><br><span class="line">[0x00000840]&gt; iE</span><br><span class="line">[Exports]</span><br><span class="line"></span><br><span class="line">nth paddr      vaddr      <span class="built_in">bind</span>   <span class="built_in">type</span>   size lib name</span><br><span class="line">―――――――――――――――――――――――――――――――――――――――――――――――――――――</span><br><span class="line">3   0x00001110 0x00001110 GLOBAL FUNC   175      Java_sg_vantagepoint_uncrackable2_CodeCheck_bar</span><br><span class="line">5   0x00001100 0x00001100 GLOBAL FUNC   15       Java_sg_vantagepoint_uncrackable2_MainActivity_init</span><br><span class="line">14  ---------- 0x00004008 GLOBAL NOTYPE 0        _edata</span><br><span class="line">15  ---------- 0x00004008 GLOBAL NOTYPE 0        __bss_start</span><br><span class="line">16  ---------- 0x0000400d GLOBAL NOTYPE 0        _end</span><br><span class="line"></span><br><span class="line">[0x00000840]&gt; </span><br></pre></td></tr></table></figure><p>在 radare2 里查看 Java_sg_vantagepoint_uncrackable2_MainActivity_init 函数</p><img src="/2021/04/04/Apk-Reverse-Engineering-03/radare2.png" class><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>或者，打开 IDA → Uncrackable-Level2/lib/libfoo.so 分析 init &amp; bar 函数（好处是可以直接F5不用看汇编）</p><img src="/2021/04/04/Apk-Reverse-Engineering-03/IDA.png" class><blockquote><p>We can see that the main process forks a child process that attaches to it as a debugger using ptrace. This is a basic anti-debugging technique.</p></blockquote><p>这也就解释了为什么一开始我们使用 frida 注入的时候会失败，因为frida本身就是使用 ptrace 进行注入，因为本身父进程已经有 debugger attach 上去了</p><h1 id="Anti-Anti-debugging"><a href="#Anti-Anti-debugging" class="headerlink" title="Anti Anti-debugging"></a>Anti Anti-debugging</h1><h2 id="Solution-1-frida"><a href="#Solution-1-frida" class="headerlink" title="Solution 1 - frida"></a>Solution 1 - frida</h2><p>关闭 Uncrackable2 程序，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -f owasp.mstg.uncrackable2 --no-pause</span><br></pre></td></tr></table></figure><p><strong>加上 -f 选项</strong> 后，这里frida不再是注入到原有运行的 Uncrackable2 程序中，而是 “spawn the process”，即首先注入到 Zygote 里去，再启动 Uncrackable2 程序</p><img src="/2021/04/04/Apk-Reverse-Engineering-03/frida-f.png" class><h2 id="Solution-2-patching"><a href="#Solution-2-patching" class="headerlink" title="Solution 2 - patching"></a>Solution 2 - patching</h2><p>另一种方式是 patch，即通过反编译、重打包、签名的流程来修改 apk，类似的操作我们在 Level 01 里也做过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apktool d -f -r UnCrackable-Level2.apk</span><br><span class="line">vim UnCrackable-Level2/smali/sg/vantagepoint/uncrackable2/MainActivity.smali <span class="comment"># 注释 init 调用，如下图</span></span><br><span class="line">apktool b UnCrackable-Level2 -o new_uncrackable.apk <span class="comment"># 重打包</span></span><br><span class="line">zipalign -v 4 new_uncrackable.apk UnCrackable2.recompiled.aligned.apk <span class="comment"># 对齐</span></span><br><span class="line">keytool -genkeypair -v -keystore my_key.keystore -<span class="built_in">alias</span> my_key -keyalg RSA -keysize 2048 -validity 10000 <span class="comment"># 产生自己的keystore</span></span><br><span class="line">jarsigner -verbose -keystore my_key.keystore UnCrackable2.recompiled.aligned.apk my_key <span class="comment"># 签名</span></span><br></pre></td></tr></table></figure><img src="/2021/04/04/Apk-Reverse-Engineering-03/comment.png" class><p>卸载原本的apk，安装新 patch 的apk</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall owasp.mstg.uncrackable2</span><br><span class="line">adb install UnCrackable2.recompiled.aligned.apk</span><br></pre></td></tr></table></figure><p>重新运行程序，使用 frida 查看发现只剩一个进程了，即成功绕过反调试</p><img src="/2021/04/04/Apk-Reverse-Engineering-03/reinstall.png" class><p>这一种方法在后面做题的时候其实会遇到问题<br>原因是：如果我们仔细观察 init 和 bar 函数，就会发现 init 函数中除了进行一次函数调用，还将 byte_400C 设置为 1</p><img src="/2021/04/04/Apk-Reverse-Engineering-03/400C.png" class><p>主要是这个值在后面 bar 函数起着关键作用，如果 byte_400C 值不为1，后面就不会进行 strncmp 调用</p><img src="/2021/04/04/Apk-Reverse-Engineering-03/400C1.png" class><p>所以这里我们直接在 smali 代码里注释掉 init 函数后，还需要额外补充 byte_400C = 1 这一步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Get base address of library</span></span><br><span class="line"><span class="keyword">var</span> libfoo = Module.findBaseAddress(<span class="string">&quot;libfoo.so&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Calculate address of variable: its offset from the base address is 0x400C bytes, based on our disassembly</span></span><br><span class="line"><span class="keyword">var</span> initialized = libfoo.add(ptr(<span class="string">&quot;0x400C&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Write 1 to the variable</span></span><br><span class="line">Memory.writeInt(initialized, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="Solving-Challenge"><a href="#Solving-Challenge" class="headerlink" title="Solving Challenge"></a>Solving Challenge</h1><h2 id="Bypass-root-detection"><a href="#Bypass-root-detection" class="headerlink" title="Bypass root detection"></a>Bypass root detection</h2><p>编写 frida 脚本，hook 掉 exit 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] Starting script&quot;</span>);</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> exitClass = Java.use(<span class="string">&quot;java.lang.System&quot;</span>);</span><br><span class="line">        exitClass.exit.implementation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;[*] System.exit called&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;[*] Hooking calls to System.exit&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后使用上一节的方法绕过 root 检测</p><img src="/2021/04/04/Apk-Reverse-Engineering-03/bypassRoot.png" class><p>这时已经可以在输入框中尝试输入 secret string 了</p><h2 id="Solution-1-reverse-engineering"><a href="#Solution-1-reverse-engineering" class="headerlink" title="Solution 1 - reverse engineering"></a>Solution 1 - reverse engineering</h2><p>该输入什么呢？从前面的反编译分析可以看到，我们输入的input最后会作为参数被放进 libfoo.so 中的 bar 函数内，该函数最后返回一个 boolean 决定了我们的输入是否验证成功</p><img src="/2021/04/04/Apk-Reverse-Engineering-03/bar.png" class><p>结合 bar 函数内容，显而易见首先校验我们输入的内容长度是否为 23，然后在于 v6 字符串（Thanks for all the fish）进行比对，如果一致则返回真</p><img src="/2021/04/04/Apk-Reverse-Engineering-03/strncmp.png" class><p>因此输入内容即为以上字符串即可过关</p><img src="/2021/04/04/Apk-Reverse-Engineering-03/success.png" class><h2 id="Solution-2-frida"><a href="#Solution-2-frida" class="headerlink" title="Solution 2 - frida"></a>Solution 2 - frida</h2><p>我们还可以通过使用 frida hook 关键的 strncmp 函数，然后打印出它的参数，这样就也可以知道 secret string 的值了<br>考虑到 strncmp 函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * str1, <span class="keyword">const</span> <span class="keyword">char</span> * str2, <span class="keyword">size_t</span> num )</span></span>;</span><br></pre></td></tr></table></figure><p>编写脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">java.Perform(<span class="function"><span class="keyword">function</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strncmp = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">imports = Module.enumerateImportsSync(<span class="string">&quot;libfoo.so&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; imports.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(imports[i].name == <span class="string">&quot;strncmp&quot;</span>) &#123;</span><br><span class="line">        strncmp = imports[i].address;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Interceptor.attach(strncmp, &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args[<span class="number">2</span>].toInt32() == <span class="number">23</span> &amp;&amp; Memory.readUtf8String(args[<span class="number">0</span>],<span class="number">23</span>) == <span class="string">&quot;01234567890123456789012&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;[*] Secret string at &quot;</span> + args[<span class="number">1</span>] + <span class="string">&quot;: &quot;</span> + Memory.readUtf8String(args[<span class="number">1</span>],<span class="number">23</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个脚本在写的时候有几个注意点：</p><ul><li>调用 Module.enumerateImportsSync 是为了获取 libfoo.so 中所有 import 组成的一个 array，具体API可以参考<a href="https://frida.re/docs/javascript-api/">手册</a></li><li>Java 里的 String 是不以 null 结尾的。如果我们使用 Memory.readUtf8String 方法去获取 strncmp 参数中的字符串指针的内容，同时不指定长度时，frida 不能知道什么时候字符串结束。因此我们需要指定长度，23</li><li>如果我们不加以限制，直接打印出所有调用 strncmp 时的参数，会发现输出会爆炸多，因为这个函数在太多地方被调用。因此，这里的小 trick 是限制仅当与输入为“01234567890123456789012”（为什么是这个？23位啊）时才会输出</li></ul><p>理论上这个方法应该是没什么问题的，但不知道为什么卡在了下面这个错误</p><img src="/2021/04/04/Apk-Reverse-Engineering-03/error.png" class><p>目前来看有可能不是语法的错误，怀疑跟这个 <a href="https://github.com/frida/frida/issues/1398">issue</a> 有关，因为这里用的安卓模拟器是genymotion，仅支持 x86 的CPU; 然后 frida 在支持 x86 上有个 bug，hook 短函数会失败 → 尚未验证</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h1&gt;&lt;p&gt;本文旨在解决 OWASP Project Android 联手项目 Level 2，关注了root检测绕过和反调试检测，而challenge本身也是寻找关键的 secret string&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Apk Reverse Engineering 02</title>
    <link href="http://example.com/2021/04/03/Apk-Reverse-Engineering-02/"/>
    <id>http://example.com/2021/04/03/Apk-Reverse-Engineering-02/</id>
    <published>2021-04-02T16:26:46.000Z</published>
    <updated>2021-04-02T16:36:47.873Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要内容包含一些基本的jdb使用方法</p><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>还是针对 Level 1 的 apk 项目进行练手，只是这次使用的方法不再是通过 reverse engineering， 而是动态 jdb 调试</p><a id="more"></a><h1 id="Attach-the-debugger"><a href="#Attach-the-debugger" class="headerlink" title="Attach the debugger"></a>Attach the debugger</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run the app in &quot;wait for debugger&quot; mode:</span></span><br><span class="line">adb shell am start -D -n <span class="string">&quot;owasp.mstg.uncrackable1/sg.vantagepoint.uncrackable1.MainActivity&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find PID by running:</span></span><br><span class="line">adb shell ps | grep uncrackable</span><br><span class="line"></span><br><span class="line"><span class="comment"># transfer debugging information from the device (emulator) to the local machine(debugger) via a established socker connection</span></span><br><span class="line">adb forward tcp:RANDOM_PORT jdwp:PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># verify that there is a socket listening</span></span><br><span class="line">lsof -i -P -n | grep LISTEN</span><br><span class="line"></span><br><span class="line"><span class="comment"># suspend the execution of the app upon debugger connecting to it</span></span><br><span class="line">(<span class="built_in">echo</span> <span class="built_in">suspend</span> &amp;&amp; cat) | jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=RANDOM_PORT</span><br></pre></td></tr></table></figure><h1 id="Bypass-root-detection"><a href="#Bypass-root-detection" class="headerlink" title="Bypass root detection"></a>Bypass root detection</h1><p>使用set方法 set <value> = <expr> 可以修改变量/数组元素/…的值</expr></value></p><img src="/2021/04/03/Apk-Reverse-Engineering-02/setValue.png" class><p>这样弹窗提示就会变成可以取消模式，在弹窗外面点击一下鼠标，程序就可以继续而不会强制退出了</p><h1 id="Solving-Challenge"><a href="#Solving-Challenge" class="headerlink" title="Solving Challenge"></a>Solving Challenge</h1><p>为了找到secret的值，需要首先去找到这个值存储在哪里</p><img src="/2021/04/03/Apk-Reverse-Engineering-02/decompile.png" class><p>通过阅读分析源代码（可以将某些变量名进行 refactor → rename），可以发现 secret 会成为 java.lang.String.equals 的参数被调用，与输入进行比对<br>这里直觉上我们应该直接在 java.lang.String.equals 处下一个断点，但很快我们会发现这个调用了太多次，会很容易迷失<br>更好的办法是，我们在更上一层的 javax.crypto.Cipher.doFinal 处下断电，等程序在这里断下来之后，再在 java.lang.String.equals 上下断点，如下图：</p><img src="/2021/04/03/Apk-Reverse-Engineering-02/setBreakpoint.png" class><p>这里没有什么指示说 “I want to believe” 一定是 secret，因此能断下来之后这里的值都需要尝试一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要内容包含一些基本的jdb使用方法&lt;/p&gt;
&lt;h1 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h1&gt;&lt;p&gt;还是针对 Level 1 的 apk 项目进行练手，只是这次使用的方法不再是通过 reverse engineering， 而是动态 jdb 调试&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Apk Reverse Engineering 01</title>
    <link href="http://example.com/2021/04/02/Apk-Reverse-Engineering-01/"/>
    <id>http://example.com/2021/04/02/Apk-Reverse-Engineering-01/</id>
    <published>2021-04-02T14:44:08.000Z</published>
    <updated>2021-04-04T09:32:59.435Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要内容包含一些基本的反编译、重打包、签名、修改 app 行为的方法</p><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>OWASP MSTG project 设计了一系列 （故意包含 vulnerability 的） apk 练手项目，其中包含4个 level，每个 level 都是通过一个 challenge 的形式，教会学习者某些技能点。<br>本文，即 Level1，关注了 root 检测绕过，而 challenge 本身是寻找关键的 secret key。</p><a id="more"></a><h1 id="Installation-of-Uncrackable-Level-1-APK"><a href="#Installation-of-Uncrackable-Level-1-APK" class="headerlink" title="Installation of Uncrackable Level 1 APK"></a>Installation of Uncrackable Level 1 APK</h1><p>首先安装<a href="https://github.com/OWASP/owasp-mstg/blob/master/Crackmes/Android/Level_01/UnCrackable-Level1.apk">Level_01/UnCrackable-Level1.apk</a></p><img src="/2021/04/02/Apk-Reverse-Engineering-01/uncrackable1.png" class><p>下载完成后，使用 adb 安装到 genymotion 的安卓模拟器里，或者直接拖拽apk安装包进去也可，打开会看到以下画面</p><div style="width:50%;margin:auto"><img src="/2021/04/02/Apk-Reverse-Engineering-01/initalStart.png" class></div>点击 ok 后程序会自动退出,这代表了程序中包含某些逻辑判断，使得程序不能在 root 下运行。由于 genymotion 的 Android API 是默认 root 状态，因此我们需要绕过这段逻辑。解决这第一个问题的办法有很多，例如动态 hook 从而在运行时解除限制、动态 debug 调试，这里我们采用第三种办法：逆向。通过反编译程序，找到判断推出的逻辑，进而删除这段逻辑达到绕过的目的。<h1 id="Root-detection-Bypass"><a href="#Root-detection-Bypass" class="headerlink" title="Root detection Bypass"></a>Root detection Bypass</h1><h2 id="Decompilation"><a href="#Decompilation" class="headerlink" title="Decompilation"></a>Decompilation</h2><p>为了理解反编译，我们可以先从编译过程开始学起。同时为了方便理解，这里将这个过程和 Java 的进行比较。<br>编译一份 Java 代码时需要进行以下步骤：</p><ul><li>写一份 Main.java 源代码</li><li>通过 javac 将 Main.java 编译为 Main.class，即字节码</li><li>JVM(Java Virtual Machine) 进行解析，使用 JIT(Just-in-time) 将 Main.class 转化为 machine code 机器码</li><li>machine code 被 CPU 执行，程序最终运行</li></ul><img src="/2021/04/02/Apk-Reverse-Engineering-01/decompile1.png" class><p>相比较而言，Android 的编译过程与以上 Java 的编译过程最大的区别在于，Android 并不使用 JVM 。原因是安卓仅有有限的处理器和内存，不适合支持 JVM。<br>所以，Android 引入了 Dalvik Virtual Machine (DVM)，过程如下：</p><img src="/2021/04/02/Apk-Reverse-Engineering-01/decompile2.png" class><p>Android的字节码叫做 Dalvik bytecode（为了与 Java 原生 bytecode 进行区分），以 *.dex 形式存储。它是 Android 源代码经过编译后产生的，之后会和 resources、manifest、META-INF 等一起打包成 zip 包，也就是我们熟悉的 *.apk 安装包。<br>首先解压APK压缩包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool d -f -r Uncrackable-Level1.apk </span><br></pre></td></tr></table></figure><h2 id="Smali-files"><a href="#Smali-files" class="headerlink" title="Smali files"></a>Smali files</h2><p>这里 -r 选项会自动将 *.dex 文件转化为 smali 文件。<br>Smali 在安卓里的角色很类似与汇编代码在 Windows 里的角色。相比与 Dalvik bytecode 来说，smali 会更加肉眼可读一些。<br>执行完毕后得到 Uncrackable-Level1 文件夹，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── AndroidManifest.xml</span><br><span class="line">├── apktool.yml</span><br><span class="line">├── build</span><br><span class="line">│   └── apk</span><br><span class="line">├── original</span><br><span class="line">│   ├── AndroidManifest.xml</span><br><span class="line">│   └── META-INF</span><br><span class="line">├── res</span><br><span class="line">│   ├── layout</span><br><span class="line">│   ├── menu</span><br><span class="line">│   ├── mipmap-hdpi-v4</span><br><span class="line">│   ├── mipmap-mdpi-v4</span><br><span class="line">│   ├── mipmap-xhdpi-v4</span><br><span class="line">│   ├── mipmap-xxhdpi-v4</span><br><span class="line">│   └── mipmap-xxxhdpi-v4</span><br><span class="line">├── resources.arsc</span><br><span class="line">└── smali</span><br><span class="line">    └── sg</span><br><span class="line">        └── vantagepoint</span><br><span class="line">            ├── a</span><br><span class="line">            │   ├── a.smali</span><br><span class="line">            │   ├── b.smali</span><br><span class="line">            │   └── c.smali</span><br><span class="line">            └── uncrackable1</span><br><span class="line">                ├── a.smali</span><br><span class="line">                ├── MainActivity<span class="variable">$1</span>.smali</span><br><span class="line">                ├── MainActivity<span class="variable">$2</span>.smali</span><br><span class="line">                └── MainActivity.smali</span><br></pre></td></tr></table></figure><h2 id="Modification"><a href="#Modification" class="headerlink" title="Modification"></a>Modification</h2><p>正常来说，如果我们要查看一个 apk 包里的可读 java 代码，需要首先使用 apktool，再使用 dex2jar，最后 jd-gui，步骤很多过于复杂。<br>其实有个更简便的小工具叫 Bytecode Viewer，可以直接将 apk 转化为可读 java 源代码，减少我们的人工工作。<br>不管怎么说，条条大路通罗马。最后的打开界面如下：</p><img src="/2021/04/02/Apk-Reverse-Engineering-01/decompileView.png" class><p>可以直接查看（反编译得到的 smali 文件）被解析成 java 源代码的形式，其中有一段代码很有意思:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    AlertDialog create = <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>).create();</span><br><span class="line">    create.setTitle(str);</span><br><span class="line">    create.setMessage(<span class="string">&quot;This is unacceptable. The app is now going to exit.&quot;</span>);</span><br><span class="line">    create.setButton(-<span class="number">3</span>, <span class="string">&quot;OK&quot;</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">        <span class="comment">/* class sg.vantagepoint.uncrackable1.MainActivity.AnonymousClass1 */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialogInterface, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    create.setCancelable(<span class="keyword">false</span>);</span><br><span class="line">    create.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* access modifiers changed from: protected */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c.a() || c.b() || c.c()) &#123;</span><br><span class="line">        a(<span class="string">&quot;Root detected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b.a(getApplicationContext())) &#123;</span><br><span class="line">        a(<span class="string">&quot;App is debuggable!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(bundle);</span><br><span class="line">    setContentView(<span class="number">2130903040</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上的逻辑就是在 onCreate 创建活动的时候，首先进行 c.a() || c.b() || c.c() 的三种方式判断是否为 root 环境，<br>如果是的话，则执行 a() 函数，同时将 “Root detected!” 作为报错信息传入。<br>a() 函数除了弹出一个报错框提示之外，还有我们关心的退出逻辑，即点击 ok 按钮后触发 onClick 函数，调用 System.exit(0) 退出程序。<br>因此这里最简单的方法去绕过 root 检测就是直接将这个 exit(0) 命令删除。为了做到这个，我们需要直接去修改 smali 文件。</p><img src="/2021/04/02/Apk-Reverse-Engineering-01/commentOutExit.png" class><p>将这一行注释掉，然后重新打包一个新的 apk</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool b UnCrackable-Level1 -o new_uncrackable.apk</span><br></pre></td></tr></table></figure><img src="/2021/04/02/Apk-Reverse-Engineering-01/newUncrackable.png" class><p>这样我们就重打包出了一个新的 apk，然后尝试把它安装回 genymotion 的模拟器</p><img src="/2021/04/02/Apk-Reverse-Engineering-01/problem.png" class><p>这里一定会遇到一个问题：INSTALL_PARSE_FAILED_NO_CERTIFICATES<br>让我们在下一节看看为什么会出现这个问题。</p><h2 id="Signing-APK-and-rebuilding"><a href="#Signing-APK-and-rebuilding" class="headerlink" title="Signing APK and rebuilding"></a>Signing APK and rebuilding</h2><p>Android 使用了一个证书机制（certificate 和 keystore）来验证 apk 的任何未来的更新都来自于原作者，从而防止恶意攻击者篡改伪造。<br>一个数字证书通常包括一对公私钥，还有一些其他辅助信息，例如 key 的主人姓名、地点等，当给一个 apk 进行签名时，签名工具会把这个数字证书附上去，从而就与原作者的 private key 一一绑定。Keystore 是一个 binary 文件，存储一个或多个 private key。<br>接下来我们就要创建一个自己的 keystore</p><img src="/2021/04/02/Apk-Reverse-Engineering-01/keystore.png" class><p>然后给我们刚刚重打包的 apk 签名</p><img src="/2021/04/02/Apk-Reverse-Engineering-01/sign.png" class><p>最后我们可以尝试重新将新的 apk 包安装回模拟器了，这次应该没问题了。</p><img src="/2021/04/02/Apk-Reverse-Engineering-01/reinstall.png" class><p>这一次虽然还是会弹出检测到不是 root 环境，但是不会强制退出。我们可以专注于解谜游戏了。</p><img src="/2021/04/02/Apk-Reverse-Engineering-01/noForceExit.png" class><h1 id="Solving-challenge"><a href="#Solving-challenge" class="headerlink" title="Solving challenge"></a>Solving challenge</h1><p>解谜游戏本身是要求输入一个 secret string，从而进行比对。经过一番研读程序（ verify 函数）我们可以看出，下图的 a.a(bArr, bArr2) 会输出 secret string 的值。</p><img src="/2021/04/02/Apk-Reverse-Engineering-01/funcA.png" class><p>这里我们使用（强大的）frida 工具，编写 Javascript 脚本去动态 hook 这个函数，修改函数实现，将 secret string 打印在控制台上。</p><ul><li>首先，在宿主机上下载安装<a href="https://github.com/frida/frida">frida</a></li><li>在安卓模拟器上启动 frida server</li></ul><img src="/2021/04/02/Apk-Reverse-Engineering-01/downloadFrida.png" class><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb root <span class="comment">#可能需要</span></span><br><span class="line">adb push ./frida-server-14.2.10-android-x86 /data/<span class="built_in">local</span>/tmp</span><br><span class="line">adb shell <span class="string">&quot;chmod 755 /data/local/tmp/frida-server-14.2.10-android-x86&quot;</span></span><br><span class="line">adb shell <span class="string">&quot;/data/local/tmp/frida-server-14.2.10-android-x86 &amp;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>编写 Javascript 脚本 hook 进程</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exp1.js</span></span><br><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aes = Java.use(<span class="string">&quot;sg.vantagepoint.a.a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hook the function inside the class</span></span><br><span class="line">    aes.a.implementation = <span class="function"><span class="keyword">function</span>(<span class="params">var0, var1</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//calling the function itself to get its return value</span></span><br><span class="line">        <span class="keyword">var</span> decrypt = <span class="built_in">this</span>.a(var0, var1);</span><br><span class="line">        <span class="keyword">var</span> flag = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//converting the returned byte array to ascii and appending to a string</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; decrypt.length; i++) &#123;</span><br><span class="line">            flag += <span class="built_in">String</span>.fromCharCode(decrypt[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//leaking our secret</span></span><br><span class="line">        <span class="built_in">console</span>.log(flag);</span><br><span class="line">        <span class="keyword">return</span> decrypt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>使用 frida 找到 uncrackable 进程，运行脚本</li></ul><img src="/2021/04/02/Apk-Reverse-Engineering-01/hook.png" class><p>这时检查模拟器上程序运行状态，在输入框里随意输入一些字符，触发 verify 函数</p><img src="/2021/04/02/Apk-Reverse-Engineering-01/verify.png" class><p>可以发现在控制台上打印出了正确的 secret string: I want to believe<br>重新输入验证结果正确</p><div style="width:50%;margin:auto"><img src="/2021/04/02/Apk-Reverse-Engineering-01/success.png" class></div>至此，Challenge 1 解谜结束。]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要内容包含一些基本的反编译、重打包、签名、修改 app 行为的方法&lt;/p&gt;
&lt;h1 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h1&gt;&lt;p&gt;OWASP MSTG project 设计了一系列 （故意包含 vulnerability 的） apk 练手项目，其中包含4个 level，每个 level 都是通过一个 challenge 的形式，教会学习者某些技能点。&lt;br&gt;本文，即 Level1，关注了 root 检测绕过，而 challenge 本身是寻找关键的 secret key。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/04/02/hello-world/"/>
    <id>http://example.com/2021/04/02/hello-world/</id>
    <published>2021-04-02T14:20:30.343Z</published>
    <updated>2021-04-02T14:20:30.343Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
