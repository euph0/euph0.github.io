<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>52pojie 2020春节解题领红包 Q3 Writeup</title>
    <url>/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/</url>
    <content><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://down.52pojie.cn/Challenge/Happy_New_Year_2020_Challenge.rar">Happy_New_Year_2020_Challenge</a></p>
<a id="more"></a>

<h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><h2 id="Java-层"><a href="#Java-层" class="headerlink" title="Java 层"></a>Java 层</h2><p>首先题目给出来是一个apk</p>
<img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/q.jpg" class>
<p>拖到jadx里打开查看</p>
<img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/jadx.png" class>
<p>发现 onCreate 函数是在 java 层实现的，而 onClick 和checkFlag都是在 native 层实现的 Native 层</p>
<h2 id="Native-层"><a href="#Native-层" class="headerlink" title="Native 层"></a>Native 层</h2><p>因此找到 libcrack_j2c.so，拖进 IDA 里查看，找到其中的两个关键函数</p>
<img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/funclist.png" class>

<h3 id="一些准备工作"><a href="#一些准备工作" class="headerlink" title="一些准备工作"></a>一些准备工作</h3><p>File → Load file → Parse C header file，导入 <a href="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/jni.h" title="jni.h">jni.h</a><br>选中函数的第一个 int 型参数，右键”Convert to struct *“，在打开的框里选择 JNIEnv，点击 ok</p>
<img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/jniEnv.png" class>
<p>选中函数名，右键“Force call type”<br>会发现大部分函数会变得更加可读一些</p>
<h3 id="分析-onClick-函数"><a href="#分析-onClick-函数" class="headerlink" title="分析 onClick 函数"></a>分析 onClick 函数</h3><img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/onClick.png" class>
<p>大意是首先判断输入长度是否为30，如果不满足则跳转输出“flag长度必须为30位”<br>如果满足的话，会调用 checkFlag 进行判断，返回一个boolean值对应输出正确与错误信息<br>因此关键就在 checkFlag 函数</p>
<h3 id="分析-checkFlag-函数"><a href="#分析-checkFlag-函数" class="headerlink" title="分析 checkFlag 函数"></a>分析 checkFlag 函数</h3><p>首先一进来是反调试</p>
<img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/antiDebug.png" class>
<p>之后是对三块内存进行字符串赋值，分别为:</p>
<ul>
<li>string 1: thisiskey </li>
<li>string 2: 52pojie_2020_happy_chinese_new_year</li>
<li>string 3: 20200125</li>
</ul>
<p>然后开辟一块新内存存放 35 位的 byte 数组</p>
<img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/byte.png" class>
<p>接下来会遍历数组，如果 i!=0 &amp;&amp; i%4==0，选取 string3 中下标为 (i&gt;&gt;2)-1 的字符填进 byte 数组，否则选取 string2 中下标为 i 的字符填进 byte 数组</p>
<img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/index.png" class>
<p>然后对这个 byte 数组做 md5 hash</p>
<img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/hash.png" class>
<p>然后将 hash 结果与 string1 循环异或 j % len(string1)</p>
<img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/xor.png" class>
<p>异或结果转 hex，不足 0xF 时高位补 0，得到 32 位字符串</p>
<img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/toHex.png" class>
<p>将结果截取[1:31]，与输入进行比较</p>
<img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/compare.png" class>
<p>因此我们只需要按照这个逻辑算一遍，就能知道答案是什么</p>
<h3 id="编写exp"><a href="#编写exp" class="headerlink" title="编写exp"></a>编写exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;thisiskey&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;52pojie_2020_happy_chinese_new_year&quot;</span></span><br><span class="line">str3 = <span class="string">&quot;20200125&quot;</span></span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">35</span>):</span><br><span class="line">    <span class="keyword">if</span> i != <span class="number">0</span> <span class="keyword">and</span> i % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        res.append(str3[(i&gt;&gt;<span class="number">2</span>)-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res.append(str2[i])</span><br><span class="line"></span><br><span class="line">res = hashlib.md5(<span class="string">&quot;&quot;</span>.join(res)).digest()</span><br><span class="line"></span><br><span class="line">code = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)):</span><br><span class="line">    tmp = <span class="built_in">ord</span>(result[i]) ^ <span class="built_in">ord</span>(str1[i % <span class="number">9</span>])</span><br><span class="line">    code.append(<span class="string">&quot;%02x&quot;</span> % tmp)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;</span>.join(code)[<span class="number">1</span>:<span class="number">31</span>])</span><br></pre></td></tr></table></figure>

<img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/output.png" class>

<p>输入即可得到正确结果</p>
<img src="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/success.jpg" class>

<p>附：<a href="/2021/04/04/52pojie-2020%E6%98%A5%E8%8A%82%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85-Q3-Writeup/libcrack_j2c.so.idb" title="libcrack_j2c.so.idb">libcrack_j2c.so.idb</a></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Apk Reverse Engineering 01</title>
    <url>/2021/04/02/Apk-Reverse-Engineering-01/</url>
    <content><![CDATA[<p>本文主要内容包含一些基本的反编译、重打包、签名、修改 app 行为的方法</p>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>OWASP MSTG project 设计了一系列 （故意包含 vulnerability 的） apk 练手项目，其中包含4个 level，每个 level 都是通过一个 challenge 的形式，教会学习者某些技能点。<br>本文，即 Level1，关注了 root 检测绕过，而 challenge 本身是寻找关键的 secret key。</p>
<a id="more"></a>

<h1 id="Installation-of-Uncrackable-Level-1-APK"><a href="#Installation-of-Uncrackable-Level-1-APK" class="headerlink" title="Installation of Uncrackable Level 1 APK"></a>Installation of Uncrackable Level 1 APK</h1><p>首先安装<a href="https://github.com/OWASP/owasp-mstg/blob/master/Crackmes/Android/Level_01/UnCrackable-Level1.apk">Level_01/UnCrackable-Level1.apk</a></p>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/uncrackable1.png" class>
<p>下载完成后，使用 adb 安装到 genymotion 的安卓模拟器里，或者直接拖拽apk安装包进去也可，打开会看到以下画面</p>
<div style="width:50%;margin:auto"><img src="/2021/04/02/Apk-Reverse-Engineering-01/initalStart.png" class></div>
点击 ok 后程序会自动退出,这代表了程序中包含某些逻辑判断，使得程序不能在 root 下运行。
由于 genymotion 的 Android API 是默认 root 状态，因此我们需要绕过这段逻辑。
解决这第一个问题的办法有很多，例如动态 hook 从而在运行时解除限制、动态 debug 调试，这里我们采用第三种办法：逆向。通过反编译程序，找到判断推出的逻辑，进而删除这段逻辑达到绕过的目的。

<h1 id="Root-detection-Bypass"><a href="#Root-detection-Bypass" class="headerlink" title="Root detection Bypass"></a>Root detection Bypass</h1><h2 id="Decompilation"><a href="#Decompilation" class="headerlink" title="Decompilation"></a>Decompilation</h2><p>为了理解反编译，我们可以先从编译过程开始学起。同时为了方便理解，这里将这个过程和 Java 的进行比较。<br>编译一份 Java 代码时需要进行以下步骤：</p>
<ul>
<li>写一份 Main.java 源代码</li>
<li>通过 javac 将 Main.java 编译为 Main.class，即字节码</li>
<li>JVM(Java Virtual Machine) 进行解析，使用 JIT(Just-in-time) 将 Main.class 转化为 machine code 机器码</li>
<li>machine code 被 CPU 执行，程序最终运行</li>
</ul>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/decompile1.png" class>
<p>相比较而言，Android 的编译过程与以上 Java 的编译过程最大的区别在于，Android 并不使用 JVM 。原因是安卓仅有有限的处理器和内存，不适合支持 JVM。<br>所以，Android 引入了 Dalvik Virtual Machine (DVM)，过程如下：</p>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/decompile2.png" class>
<p>Android的字节码叫做 Dalvik bytecode（为了与 Java 原生 bytecode 进行区分），以 *.dex 形式存储。它是 Android 源代码经过编译后产生的，之后会和 resources、manifest、META-INF 等一起打包成 zip 包，也就是我们熟悉的 *.apk 安装包。<br>首先解压APK压缩包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apktool d -f -r Uncrackable-Level1.apk </span><br></pre></td></tr></table></figure>

<h2 id="Smali-files"><a href="#Smali-files" class="headerlink" title="Smali files"></a>Smali files</h2><p>这里 -r 选项会自动将 *.dex 文件转化为 smali 文件。<br>Smali 在安卓里的角色很类似与汇编代码在 Windows 里的角色。相比与 Dalvik bytecode 来说，smali 会更加肉眼可读一些。<br>执行完毕后得到 Uncrackable-Level1 文件夹，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── AndroidManifest.xml</span><br><span class="line">├── apktool.yml</span><br><span class="line">├── build</span><br><span class="line">│   └── apk</span><br><span class="line">├── original</span><br><span class="line">│   ├── AndroidManifest.xml</span><br><span class="line">│   └── META-INF</span><br><span class="line">├── res</span><br><span class="line">│   ├── layout</span><br><span class="line">│   ├── menu</span><br><span class="line">│   ├── mipmap-hdpi-v4</span><br><span class="line">│   ├── mipmap-mdpi-v4</span><br><span class="line">│   ├── mipmap-xhdpi-v4</span><br><span class="line">│   ├── mipmap-xxhdpi-v4</span><br><span class="line">│   └── mipmap-xxxhdpi-v4</span><br><span class="line">├── resources.arsc</span><br><span class="line">└── smali</span><br><span class="line">    └── sg</span><br><span class="line">        └── vantagepoint</span><br><span class="line">            ├── a</span><br><span class="line">            │   ├── a.smali</span><br><span class="line">            │   ├── b.smali</span><br><span class="line">            │   └── c.smali</span><br><span class="line">            └── uncrackable1</span><br><span class="line">                ├── a.smali</span><br><span class="line">                ├── MainActivity<span class="variable">$1</span>.smali</span><br><span class="line">                ├── MainActivity<span class="variable">$2</span>.smali</span><br><span class="line">                └── MainActivity.smali</span><br></pre></td></tr></table></figure>

<h2 id="Modification"><a href="#Modification" class="headerlink" title="Modification"></a>Modification</h2><p>正常来说，如果我们要查看一个 apk 包里的可读 java 代码，需要首先使用 apktool，再使用 dex2jar，最后 jd-gui，步骤很多过于复杂。<br>其实有个更简便的小工具叫 Bytecode Viewer，可以直接将 apk 转化为可读 java 源代码，减少我们的人工工作。<br>不管怎么说，条条大路通罗马。最后的打开界面如下：</p>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/decompileView.png" class>
<p>可以直接查看（反编译得到的 smali 文件）被解析成 java 源代码的形式，其中有一段代码很有意思:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    AlertDialog create = <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>).create();</span><br><span class="line">    create.setTitle(str);</span><br><span class="line">    create.setMessage(<span class="string">&quot;This is unacceptable. The app is now going to exit.&quot;</span>);</span><br><span class="line">    create.setButton(-<span class="number">3</span>, <span class="string">&quot;OK&quot;</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">        <span class="comment">/* class sg.vantagepoint.uncrackable1.MainActivity.AnonymousClass1 */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialogInterface, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    create.setCancelable(<span class="keyword">false</span>);</span><br><span class="line">    create.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* access modifiers changed from: protected */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c.a() || c.b() || c.c()) &#123;</span><br><span class="line">        a(<span class="string">&quot;Root detected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b.a(getApplicationContext())) &#123;</span><br><span class="line">        a(<span class="string">&quot;App is debuggable!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(bundle);</span><br><span class="line">    setContentView(<span class="number">2130903040</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上的逻辑就是在 onCreate 创建活动的时候，首先进行 c.a() || c.b() || c.c() 的三种方式判断是否为 root 环境，<br>如果是的话，则执行 a() 函数，同时将 “Root detected!” 作为报错信息传入。<br>a() 函数除了弹出一个报错框提示之外，还有我们关心的退出逻辑，即点击 ok 按钮后触发 onClick 函数，调用 System.exit(0) 退出程序。<br>因此这里最简单的方法去绕过 root 检测就是直接将这个 exit(0) 命令删除。为了做到这个，我们需要直接去修改 smali 文件。</p>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/commentOutExit.png" class>
<p>将这一行注释掉，然后重新打包一个新的 apk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apktool b UnCrackable-Level1 -o new_uncrackable.apk</span><br></pre></td></tr></table></figure>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/newUncrackable.png" class>
<p>这样我们就重打包出了一个新的 apk，然后尝试把它安装回 genymotion 的模拟器</p>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/problem.png" class>
<p>这里一定会遇到一个问题：INSTALL_PARSE_FAILED_NO_CERTIFICATES<br>让我们在下一节看看为什么会出现这个问题。</p>
<h2 id="Signing-APK-and-rebuilding"><a href="#Signing-APK-and-rebuilding" class="headerlink" title="Signing APK and rebuilding"></a>Signing APK and rebuilding</h2><p>Android 使用了一个证书机制（certificate 和 keystore）来验证 apk 的任何未来的更新都来自于原作者，从而防止恶意攻击者篡改伪造。<br>一个数字证书通常包括一对公私钥，还有一些其他辅助信息，例如 key 的主人姓名、地点等，当给一个 apk 进行签名时，签名工具会把这个数字证书附上去，从而就与原作者的 private key 一一绑定。Keystore 是一个 binary 文件，存储一个或多个 private key。<br>接下来我们就要创建一个自己的 keystore</p>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/keystore.png" class>
<p>然后给我们刚刚重打包的 apk 签名</p>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/sign.png" class>
<p>最后我们可以尝试重新将新的 apk 包安装回模拟器了，这次应该没问题了。</p>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/reinstall.png" class>
<p>这一次虽然还是会弹出检测到不是 root 环境，但是不会强制退出。我们可以专注于解谜游戏了。</p>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/noForceExit.png" class>

<h1 id="Solving-challenge"><a href="#Solving-challenge" class="headerlink" title="Solving challenge"></a>Solving challenge</h1><p>解谜游戏本身是要求输入一个 secret string，从而进行比对。经过一番研读程序（ verify 函数）我们可以看出，下图的 a.a(bArr, bArr2) 会输出 secret string 的值。</p>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/funcA.png" class>
<p>这里我们使用（强大的）frida 工具，编写 Javascript 脚本去动态 hook 这个函数，修改函数实现，将 secret string 打印在控制台上。</p>
<ul>
<li>首先，在宿主机上下载安装<a href="https://github.com/frida/frida">frida</a></li>
<li>在安卓模拟器上启动 frida server</li>
</ul>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/downloadFrida.png" class>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb root <span class="comment">#可能需要</span></span><br><span class="line">adb push ./frida-server-14.2.10-android-x86 /data/<span class="built_in">local</span>/tmp</span><br><span class="line">adb shell <span class="string">&quot;chmod 755 /data/local/tmp/frida-server-14.2.10-android-x86&quot;</span></span><br><span class="line">adb shell <span class="string">&quot;/data/local/tmp/frida-server-14.2.10-android-x86 &amp;&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>编写 Javascript 脚本 hook 进程</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exp1.js</span></span><br><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aes = Java.use(<span class="string">&quot;sg.vantagepoint.a.a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hook the function inside the class</span></span><br><span class="line">    aes.a.implementation = <span class="function"><span class="keyword">function</span>(<span class="params">var0, var1</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//calling the function itself to get its return value</span></span><br><span class="line">        <span class="keyword">var</span> decrypt = <span class="built_in">this</span>.a(var0, var1);</span><br><span class="line">        <span class="keyword">var</span> flag = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//converting the returned byte array to ascii and appending to a string</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; decrypt.length; i++) &#123;</span><br><span class="line">            flag += <span class="built_in">String</span>.fromCharCode(decrypt[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//leaking our secret</span></span><br><span class="line">        <span class="built_in">console</span>.log(flag);</span><br><span class="line">        <span class="keyword">return</span> decrypt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 frida 找到 uncrackable 进程，运行脚本</li>
</ul>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/hook.png" class>
<p>这时检查模拟器上程序运行状态，在输入框里随意输入一些字符，触发 verify 函数</p>
<img src="/2021/04/02/Apk-Reverse-Engineering-01/verify.png" class>
<p>可以发现在控制台上打印出了正确的 secret string: I want to believe<br>重新输入验证结果正确</p>
<div style="width:50%;margin:auto"><img src="/2021/04/02/Apk-Reverse-Engineering-01/success.png" class></div>
至此，Challenge 1 解谜结束。
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Apk Reverse Engineering 02</title>
    <url>/2021/04/03/Apk-Reverse-Engineering-02/</url>
    <content><![CDATA[<p>本文主要内容包含一些基本的jdb使用方法</p>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>还是针对 Level 1 的 apk 项目进行练手，只是这次使用的方法不再是通过 reverse engineering， 而是动态 jdb 调试</p>
<a id="more"></a>

<h1 id="Attach-the-debugger"><a href="#Attach-the-debugger" class="headerlink" title="Attach the debugger"></a>Attach the debugger</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run the app in &quot;wait for debugger&quot; mode:</span></span><br><span class="line">adb shell am start -D -n <span class="string">&quot;owasp.mstg.uncrackable1/sg.vantagepoint.uncrackable1.MainActivity&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find PID by running:</span></span><br><span class="line">adb shell ps | grep uncrackable</span><br><span class="line"></span><br><span class="line"><span class="comment"># transfer debugging information from the device (emulator) to the local machine(debugger) via a established socker connection</span></span><br><span class="line">adb forward tcp:RANDOM_PORT jdwp:PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># verify that there is a socket listening</span></span><br><span class="line">lsof -i -P -n | grep LISTEN</span><br><span class="line"></span><br><span class="line"><span class="comment"># suspend the execution of the app upon debugger connecting to it</span></span><br><span class="line">(<span class="built_in">echo</span> <span class="built_in">suspend</span> &amp;&amp; cat) | jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=RANDOM_PORT</span><br></pre></td></tr></table></figure>

<h1 id="Bypass-root-detection"><a href="#Bypass-root-detection" class="headerlink" title="Bypass root detection"></a>Bypass root detection</h1><p>使用set方法 set <value> = <expr> 可以修改变量/数组元素/…的值</expr></value></p>
<img src="/2021/04/03/Apk-Reverse-Engineering-02/setValue.png" class>
<p>这样弹窗提示就会变成可以取消模式，在弹窗外面点击一下鼠标，程序就可以继续而不会强制退出了</p>
<h1 id="Solving-Challenge"><a href="#Solving-Challenge" class="headerlink" title="Solving Challenge"></a>Solving Challenge</h1><p>为了找到secret的值，需要首先去找到这个值存储在哪里</p>
<img src="/2021/04/03/Apk-Reverse-Engineering-02/decompile.png" class>
<p>通过阅读分析源代码（可以将某些变量名进行 refactor → rename），可以发现 secret 会成为 java.lang.String.equals 的参数被调用，与输入进行比对<br>这里直觉上我们应该直接在 java.lang.String.equals 处下一个断点，但很快我们会发现这个调用了太多次，会很容易迷失<br>更好的办法是，我们在更上一层的 javax.crypto.Cipher.doFinal 处下断电，等程序在这里断下来之后，再在 java.lang.String.equals 上下断点，如下图：</p>
<img src="/2021/04/03/Apk-Reverse-Engineering-02/setBreakpoint.png" class>
<p>这里没有什么指示说 “I want to believe” 一定是 secret，因此能断下来之后这里的值都需要尝试一下。</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Apk Reverse Engineering 03</title>
    <url>/2021/04/04/Apk-Reverse-Engineering-03/</url>
    <content><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>本文旨在解决 OWASP Project Android 联手项目 Level 2，关注了root检测绕过和反调试检测，而challenge本身也是寻找关键的 secret string</p>
<a id="more"></a>

<h1 id="Dive-in"><a href="#Dive-in" class="headerlink" title="Dive in"></a>Dive in</h1><p>首先还是老样子，安装apk到安卓模拟器里</p>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/install.png" class>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/frida_fail.png" class>

<p>这时我们尝试去attach其中的一个进程会发现失败，失败原因后面会解释<br>那只能先反编译看一下源码了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># decompile and convert to source code</span></span><br><span class="line">apkx -d cfr Uncrackable2-Level2.apk</span><br></pre></td></tr></table></figure>

<img src="/2021/04/04/Apk-Reverse-Engineering-03/decompile.png" class>

<p>可以看到里面的一些特别之处在于：</p>
<ul>
<li>静态load 了一个 libfoo.so</li>
<li>在 onCreate 方法里调用了 native 函数 init，另外这个 init 函数里面还又调用了 bar 函数</li>
</ul>
<p>那么很显而易见，在这个库里肯定有文章<br>这里可以使用radare2/IDA查看</p>
<h2 id="Radare2"><a href="#Radare2" class="headerlink" title="Radare2"></a>Radare2</h2><ul>
<li>下载安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install radare2</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/radareorg/radare2</span><br><span class="line"><span class="built_in">cd</span> radare2</span><br><span class="line">sys/install.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># using radare2</span></span><br><span class="line">&gt; r2 ./libfoo.so</span><br><span class="line">Cannot determine entrypoint, using 0x00000840.</span><br><span class="line">Warning: run r2 with -e io.cache=<span class="literal">true</span> to fix relocations <span class="keyword">in</span> disassembly</span><br><span class="line"> -- Here be dragons.</span><br><span class="line">[0x00000840]&gt; aaa</span><br><span class="line">[x] Analyze all flags starting with sym. and entry0 (aa)</span><br><span class="line">[x] Analyze <span class="keyword">function</span> calls (aac)</span><br><span class="line">[x] Analyze len bytes of instructions <span class="keyword">for</span> references (aar)</span><br><span class="line">[x] Check <span class="keyword">for</span> vtables</span><br><span class="line">[x] Type matching analysis <span class="keyword">for</span> all <span class="built_in">functions</span> (aaft)</span><br><span class="line">[x] Propagate noreturn information</span><br><span class="line">[x] Use -AA or aaaa to perform additional experimental analysis.</span><br><span class="line">[0x00000840]&gt; iE</span><br><span class="line">[Exports]</span><br><span class="line"></span><br><span class="line">nth paddr      vaddr      <span class="built_in">bind</span>   <span class="built_in">type</span>   size lib name</span><br><span class="line">―――――――――――――――――――――――――――――――――――――――――――――――――――――</span><br><span class="line">3   0x00001110 0x00001110 GLOBAL FUNC   175      Java_sg_vantagepoint_uncrackable2_CodeCheck_bar</span><br><span class="line">5   0x00001100 0x00001100 GLOBAL FUNC   15       Java_sg_vantagepoint_uncrackable2_MainActivity_init</span><br><span class="line">14  ---------- 0x00004008 GLOBAL NOTYPE 0        _edata</span><br><span class="line">15  ---------- 0x00004008 GLOBAL NOTYPE 0        __bss_start</span><br><span class="line">16  ---------- 0x0000400d GLOBAL NOTYPE 0        _end</span><br><span class="line"></span><br><span class="line">[0x00000840]&gt; </span><br></pre></td></tr></table></figure>

<p>在 radare2 里查看 Java_sg_vantagepoint_uncrackable2_MainActivity_init 函数</p>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/radare2.png" class>

<h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>或者，打开 IDA → Uncrackable-Level2/lib/libfoo.so 分析 init &amp; bar 函数（好处是可以直接F5不用看汇编）</p>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/IDA.png" class>
<blockquote><p>We can see that the main process forks a child process that attaches to it as a debugger using ptrace. This is a basic anti-debugging technique.</p>
</blockquote>
<p>这也就解释了为什么一开始我们使用 frida 注入的时候会失败，因为frida本身就是使用 ptrace 进行注入，因为本身父进程已经有 debugger attach 上去了</p>
<h1 id="Anti-Anti-debugging"><a href="#Anti-Anti-debugging" class="headerlink" title="Anti Anti-debugging"></a>Anti Anti-debugging</h1><h2 id="Solution-1-frida"><a href="#Solution-1-frida" class="headerlink" title="Solution 1 - frida"></a>Solution 1 - frida</h2><p>关闭 Uncrackable2 程序，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frida -U -f owasp.mstg.uncrackable2 --no-pause</span><br></pre></td></tr></table></figure>
<p><strong>加上 -f 选项</strong> 后，这里frida不再是注入到原有运行的 Uncrackable2 程序中，而是 “spawn the process”，即首先注入到 Zygote 里去，再启动 Uncrackable2 程序</p>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/frida-f.png" class>

<h2 id="Solution-2-patching"><a href="#Solution-2-patching" class="headerlink" title="Solution 2 - patching"></a>Solution 2 - patching</h2><p>另一种方式是 patch，即通过反编译、重打包、签名的流程来修改 apk，类似的操作我们在 Level 01 里也做过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apktool d -f -r UnCrackable-Level2.apk</span><br><span class="line">vim UnCrackable-Level2/smali/sg/vantagepoint/uncrackable2/MainActivity.smali <span class="comment"># 注释 init 调用，如下图</span></span><br><span class="line">apktool b UnCrackable-Level2 -o new_uncrackable.apk <span class="comment"># 重打包</span></span><br><span class="line">zipalign -v 4 new_uncrackable.apk UnCrackable2.recompiled.aligned.apk <span class="comment"># 对齐</span></span><br><span class="line">keytool -genkeypair -v -keystore my_key.keystore -<span class="built_in">alias</span> my_key -keyalg RSA -keysize 2048 -validity 10000 <span class="comment"># 产生自己的keystore</span></span><br><span class="line">jarsigner -verbose -keystore my_key.keystore UnCrackable2.recompiled.aligned.apk my_key <span class="comment"># 签名</span></span><br></pre></td></tr></table></figure>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/comment.png" class>
<p>卸载原本的apk，安装新 patch 的apk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb uninstall owasp.mstg.uncrackable2</span><br><span class="line">adb install UnCrackable2.recompiled.aligned.apk</span><br></pre></td></tr></table></figure>
<p>重新运行程序，使用 frida 查看发现只剩一个进程了，即成功绕过反调试</p>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/reinstall.png" class>
<p>这一种方法在后面做题的时候其实会遇到问题<br>原因是：如果我们仔细观察 init 和 bar 函数，就会发现 init 函数中除了进行一次函数调用，还将 byte_400C 设置为 1</p>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/400C.png" class>
<p>主要是这个值在后面 bar 函数起着关键作用，如果 byte_400C 值不为1，后面就不会进行 strncmp 调用</p>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/400C1.png" class>
<p>所以这里我们直接在 smali 代码里注释掉 init 函数后，还需要额外补充 byte_400C = 1 这一步</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Get base address of library</span></span><br><span class="line"><span class="keyword">var</span> libfoo = Module.findBaseAddress(<span class="string">&quot;libfoo.so&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Calculate address of variable: its offset from the base address is 0x400C bytes, based on our disassembly</span></span><br><span class="line"><span class="keyword">var</span> initialized = libfoo.add(ptr(<span class="string">&quot;0x400C&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Write 1 to the variable</span></span><br><span class="line">Memory.writeInt(initialized, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Solving-Challenge"><a href="#Solving-Challenge" class="headerlink" title="Solving Challenge"></a>Solving Challenge</h1><h2 id="Bypass-root-detection"><a href="#Bypass-root-detection" class="headerlink" title="Bypass root detection"></a>Bypass root detection</h2><p>编写 frida 脚本，hook 掉 exit 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] Starting script&quot;</span>);</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> exitClass = Java.use(<span class="string">&quot;java.lang.System&quot;</span>);</span><br><span class="line">        exitClass.exit.implementation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;[*] System.exit called&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;[*] Hooking calls to System.exit&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后使用上一节的方法绕过 root 检测</p>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/bypassRoot.png" class>
<p>这时已经可以在输入框中尝试输入 secret string 了</p>
<h2 id="Solution-1-reverse-engineering"><a href="#Solution-1-reverse-engineering" class="headerlink" title="Solution 1 - reverse engineering"></a>Solution 1 - reverse engineering</h2><p>该输入什么呢？从前面的反编译分析可以看到，我们输入的input最后会作为参数被放进 libfoo.so 中的 bar 函数内，该函数最后返回一个 boolean 决定了我们的输入是否验证成功</p>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/bar.png" class>
<p>结合 bar 函数内容，显而易见首先校验我们输入的内容长度是否为 23，然后在于 v6 字符串（Thanks for all the fish）进行比对，如果一致则返回真</p>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/strncmp.png" class>
<p>因此输入内容即为以上字符串即可过关</p>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/success.png" class>

<h2 id="Solution-2-frida"><a href="#Solution-2-frida" class="headerlink" title="Solution 2 - frida"></a>Solution 2 - frida</h2><p>我们还可以通过使用 frida hook 关键的 strncmp 函数，然后打印出它的参数，这样就也可以知道 secret string 的值了<br>考虑到 strncmp 函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * str1, <span class="keyword">const</span> <span class="keyword">char</span> * str2, <span class="keyword">size_t</span> num )</span></span>;</span><br></pre></td></tr></table></figure>
<p>编写脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">java.Perform(<span class="function"><span class="keyword">function</span>) </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> strncmp = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">	imports = Module.enumerateImportsSync(<span class="string">&quot;libfoo.so&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; imports.length; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(imports[i].name == <span class="string">&quot;strncmp&quot;</span>) &#123;</span><br><span class="line">        	strncmp = imports[i].address;</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Interceptor.attach(strncmp, &#123;</span><br><span class="line">    	onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        	<span class="keyword">if</span>(args[<span class="number">2</span>].toInt32() == <span class="number">23</span> &amp;&amp; Memory.readUtf8String(args[<span class="number">0</span>],<span class="number">23</span>) == <span class="string">&quot;01234567890123456789012&quot;</span>) &#123;</span><br><span class="line">            	<span class="built_in">console</span>.log(<span class="string">&quot;[*] Secret string at &quot;</span> + args[<span class="number">1</span>] + <span class="string">&quot;: &quot;</span> + Memory.readUtf8String(args[<span class="number">1</span>],<span class="number">23</span>));</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个脚本在写的时候有几个注意点：</p>
<ul>
<li>调用 Module.enumerateImportsSync 是为了获取 libfoo.so 中所有 import 组成的一个 array，具体API可以参考<a href="https://frida.re/docs/javascript-api/">手册</a></li>
<li>Java 里的 String 是不以 null 结尾的。如果我们使用 Memory.readUtf8String 方法去获取 strncmp 参数中的字符串指针的内容，同时不指定长度时，frida 不能知道什么时候字符串结束。因此我们需要指定长度，23</li>
<li>如果我们不加以限制，直接打印出所有调用 strncmp 时的参数，会发现输出会爆炸多，因为这个函数在太多地方被调用。因此，这里的小 trick 是限制仅当与输入为“01234567890123456789012”（为什么是这个？23位啊）时才会输出</li>
</ul>
<p>理论上这个方法应该是没什么问题的，但不知道为什么卡在了下面这个错误</p>
<img src="/2021/04/04/Apk-Reverse-Engineering-03/error.png" class>
<p>目前来看有可能不是语法的错误，怀疑跟这个 <a href="https://github.com/frida/frida/issues/1398">issue</a> 有关，因为这里用的安卓模拟器是genymotion，仅支持 x86 的CPU; 然后 frida 在支持 x86 上有个 bug，hook 短函数会失败 → 尚未验证</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
